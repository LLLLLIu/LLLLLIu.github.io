{"meta":{"title":"迷失的鹿hold | 个人博客","subtitle":"个人博客","description":"这个人很懒，没有任何描述","author":"迷失的鹿hold","url":"http://blog.liurenjie.top"},"pages":[{"title":"About","date":"2018-05-17T06:36:52.233Z","updated":"2018-05-17T06:36:52.219Z","comments":true,"path":"about/index.html","permalink":"http://blog.liurenjie.top/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-17T06:35:49.195Z","updated":"2018-05-17T06:35:49.163Z","comments":true,"path":"categories/index.html","permalink":"http://blog.liurenjie.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-17T06:30:12.084Z","updated":"2018-05-17T02:54:17.319Z","comments":true,"path":"tags/index.html","permalink":"http://blog.liurenjie.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo博客建立一个聊天组","slug":"hexo2018-06-01-4","date":"2018-06-01T18:02:43.000Z","updated":"2018-06-04T02:59:28.553Z","comments":true,"path":"posts/b6fa0ec.html","link":"","permalink":"http://blog.liurenjie.top/posts/b6fa0ec.html","excerpt":"hexo-gitterA generator for Hexo that adds Gitter to every page.Install1$ npm install hexo-gitter --saveUsageAdd the hexo-gitter to your theme template1&lt;%- gitter(&apos;RoomName&apos;) %&gt;RoomName represents Gitter’s room, which can be found on the Gitter website","text":"hexo-gitterA generator for Hexo that adds Gitter to every page.Install1$ npm install hexo-gitter --saveUsageAdd the hexo-gitter to your theme template1&lt;%- gitter(&apos;RoomName&apos;) %&gt;RoomName represents Gitter’s room, which can be found on the Gitter websiteExamples1&lt;%- gitter(&apos;wshunli/hexo-gitter&apos;) %&gt;License123456789101112131415161718192021MIT LicenseCopyright (c) 2018 wshunliPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.gitter中创建一个小组安装到hexo博客1&lt;%- gitter(&apos;RoomName&apos;) %&gt;设置Add people to this room : 添加github用户到房间（欢迎添加我）。Share this chat room ：分享房间Notifications ：通知方式Integrations ：集成设置，我集成了github/LLLLLIu/LLLLLIu.github.io 项目的动态。tags: 设置房间标签Settings ：设置游客或github用户进入房间的欢迎语Permissions ：权限设置Archives ：查看房间活跃度Delete this room ：删除房间Leave this room ：离开房间gitter中文手册博客中右下角就是gitter.im的控件，可以聊天试试。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.liurenjie.top/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.liurenjie.top/tags/hexo/"},{"name":"chat","slug":"chat","permalink":"http://blog.liurenjie.top/tags/chat/"},{"name":"gitter","slug":"gitter","permalink":"http://blog.liurenjie.top/tags/gitter/"}]},{"title":"添加网站的专属客服(免费版)","slug":"other2018-06-01-3","date":"2018-06-01T17:37:43.000Z","updated":"2018-06-01T09:40:32.520Z","comments":true,"path":"posts/75ff714c.html","link":"","permalink":"http://blog.liurenjie.top/posts/75ff714c.html","excerpt":"“DaoVoice 帮我们更好地运营用户。实时在线沟通，可更快解决用户问题。后台管理可帮我们建立用户画像，针对不同的用户需求进行精准运营。此外，DaoVoice 团队会快速响应我们的反馈，给予高质量服务支持。”","text":"“DaoVoice 帮我们更好地运营用户。实时在线沟通，可更快解决用户问题。后台管理可帮我们建立用户画像，针对不同的用户需求进行精准运营。此外，DaoVoice 团队会快速响应我们的反馈，给予高质量服务支持。”daovoice官网注册账户进入控台后添加一个公司账户，根据自己的应用场景创建 安装到网站如果网站没有用户体系，可以选择匿名聊天安装。应用设置聊天设置：设置个性化自动回复，样式设置成员管理：添加员工微信集成：绑定已认证的微信公众号小技巧点击头像-&gt;微信绑定-&gt;绑定后可以用daovoice的小程序和用户聊天","categories":[{"name":"other","slug":"other","permalink":"http://blog.liurenjie.top/categories/other/"}],"tags":[{"name":"chat","slug":"chat","permalink":"http://blog.liurenjie.top/tags/chat/"},{"name":"wechat","slug":"wechat","permalink":"http://blog.liurenjie.top/tags/wechat/"}]},{"title":"微信公众号接入图灵机器人","slug":"other2018-06-01-2","date":"2018-06-01T17:25:43.000Z","updated":"2018-06-01T09:25:26.131Z","comments":true,"path":"posts/3df5bcdc.html","link":"","permalink":"http://blog.liurenjie.top/posts/3df5bcdc.html","excerpt":"简介图灵机器人API是在人工智能的核心能力（包括语义理解、智能问答、场景交互、知识管理等）的基础上，为广大开发者、合作伙伴和企业提供的一系列基于云计算和大数据平台的在线服务和开发接口。开发者可以利用图灵机器人的API创建各种在线服务，灵活定义机器人的属性、编辑机器人的智能问答内容，打造个人专属智能交互机器人，也支持多渠道（微信公众平台、QQ聊天）的快速接入。","text":"简介图灵机器人API是在人工智能的核心能力（包括语义理解、智能问答、场景交互、知识管理等）的基础上，为广大开发者、合作伙伴和企业提供的一系列基于云计算和大数据平台的在线服务和开发接口。开发者可以利用图灵机器人的API创建各种在线服务，灵活定义机器人的属性、编辑机器人的智能问答内容，打造个人专属智能交互机器人，也支持多渠道（微信公众平台、QQ聊天）的快速接入。图灵机器人官网注册账号在管理页面中选中创建机器人根据自己的应用场景选择相应的选项管理页中会显示刚刚创建的机器人，点击机器人设置在终端设置中点击添加微信公众号你必须开通一个属于自己的公众号，并且用绑定的微信扫一扫就可以绑定上了（不需要认证）。打开你的公众号聊天好了，属于你的图灵机器人已经创建成功了，更多有趣的事可以自己去发现吧！！","categories":[{"name":"other","slug":"other","permalink":"http://blog.liurenjie.top/categories/other/"}],"tags":[{"name":"图灵机器人","slug":"图灵机器人","permalink":"http://blog.liurenjie.top/tags/图灵机器人/"},{"name":"wechat","slug":"wechat","permalink":"http://blog.liurenjie.top/tags/wechat/"}]},{"title":"hexo添加文章的阅读数(leancloud云存储)","slug":"hexo2018-06-01-1","date":"2018-06-01T16:53:43.000Z","updated":"2018-06-01T10:09:11.945Z","comments":true,"path":"posts/eaead48d.html","link":"","permalink":"http://blog.liurenjie.top/posts/eaead48d.html","excerpt":"数据leancloud数据是一切应用的基础。LeanCloud 为你提供可靠的数据与文件存储功能，同时提供常见的通用数据模型。结构化存储我们支持任意类型的 JSON 对象，以及对象之间的关联映射，同时提供完整的增删改查操作接口。移动社区架构我们提供了常见的用户关系模型，不仅包括用户资料、互相关注等社交属性，还包括朋友圈、动态消息等常见社区功能。ACL 权限控制","text":"数据leancloud数据是一切应用的基础。LeanCloud 为你提供可靠的数据与文件存储功能，同时提供常见的通用数据模型。结构化存储我们支持任意类型的 JSON 对象，以及对象之间的关联映射，同时提供完整的增删改查操作接口。移动社区架构我们提供了常见的用户关系模型，不仅包括用户资料、互相关注等社交属性，还包括朋友圈、动态消息等常见社区功能。ACL 权限控制基于业界标准研发的 ACL 权限控制体系，让你不仅可以确保数据安全，同时也可基于 ACL 快速开发属于自己的用户权限功能。文件存储与 CDN自动提供弹性空间和多副本的冗余备份策略，同时默认支持多个 CDN 加速节点，实时同步、南北互通。利用leancloud做云存储实现文章阅读数记录leancloud参考文档注册leancloud账号进入控制台-》存储创建class在设置中找到自己的appkey,appid需要引入的js&lt;%- js(&#39;https://cdn1.lncld.net/static/js/av-min-1.2.1.js&#39;) %&gt;文章显示数量的地方加上&lt;span id=&quot;&lt;%= url_for(post.path) %&gt;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&lt;%- post.title %&gt;&quot;&gt;0&lt;/span&gt;主要的js，添加显示功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;script type=\"text/javascript\" &gt; AV.init(&#123; //初始化 appId: '&lt;%= theme.leancloud_visitors.app_id %&gt;', appKey: '&lt;%= theme.leancloud_visitors.app_key %&gt;' &#125;); $(function () &#123; var Counter = AV.Object.extend(\"Counter\");//刚刚添加的class名 if($(\".leancloud_visitors\").length &gt; 1) console.log('home'); else addCount(Counter); if($(\".leancloud_visitors\").length &gt; 1) showListCount(Counter); else showCount(Counter); &#125;); // 追加pv function addCount (Counter) &#123; url=$(\".leancloud_visitors\").length &gt; 0 ? $(\".leancloud_visitors\").attr('id').trim() : 'blog.liurenjie.top'; title = $(\".leancloud_visitors\").attr('data-flag-title').trim(); var query=new AV.Query(Counter); //根据title&amp;&amp;url搜索记录 query.equalTo(\"title\",title); query.equalTo(\"url\",url); query.find(&#123; success: function(results)&#123; if(results.length&gt;0) &#123; var counter=results[0]; counter.fetchWhenSave(true); //get recent result counter.increment(\"time\"); counter.save(); &#125; else &#123; var newcounter=new Counter(); newcounter.set(\"title\",title); newcounter.set(\"url\",url); newcounter.set(\"time\",1); newcounter.save(null,&#123; success: function(newcounter)&#123; //alert('New object created'); &#125;, error: function(newcounter,error)&#123; alert('Failed to create'); &#125; &#125;); &#125; &#125;, error: function(error)&#123; //find null is not a error alert('Error:'+error.code+\" \"+error.message); &#125; &#125;); &#125; // 显示次数 function showCount(Counter) &#123; var query = new AV.Query(\"Counter\"); if($(\".leancloud_visitors\").length &gt; 0)&#123; var url = $(\".leancloud_visitors\").attr('id').trim(); var title = $(\".leancloud_visitors\").attr('data-flag-title').trim(); // where field query.equalTo(\"url\", url); query.equalTo(\"title\", title); // count query.find(function (result) &#123; // There are number instances of MyClass where words equals url. var count = result[0].get(\"time\"); $(document.getElementById(url)).text(count? count : '0'); &#125;, function (error) &#123; // error is an instance of AVError. alert(\"Error:\"+error.code+\" \"+error.message); &#125;); &#125; &#125; // 显示列表所有的阅读数 function showListCount(Counter)&#123; var query=new AV.Query(Counter); query.descending(\"time\"); query.containedIn('url',getPageIds()); // the sum of popular posts // query.limit('&lt;%= theme.page_size %&gt;'); query.find(&#123; success: function(results)&#123; for(var i=0;i&lt;results.length;i++) &#123; var counter=results[i]; title=counter.get(\"title\"); url=counter.get(\"url\"); time=counter.get(\"time\"); // add to the popularlist widget showcontent=title+\" (\"+time+\")\"; //notice the \"\" in href $(document.getElementById(url)).text(time? time : '0'); &#125; &#125;, error: function(error)&#123; alert(\"Error:\"+error.code+\" \"+error.message); &#125; &#125; ) &#125; // 获取当前页所有主键 function getPageIds()&#123; var lcs = $(\".leancloud_visitors\"); var length = lcs.length; var urls = new Array(); for(var i = 0 ; i &lt; length ; i ++)&#123; urls.push(lcs[i].id); &#125; return urls; &#125;&lt;/script&gt;请务必配置 Web 安全域名，方法是进入 `控制台 &gt; 设置 &gt; 安全中心 &gt; Web 安全域名就会显示想本博客一样的，列表中显示阅读数。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.liurenjie.top/categories/hexo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"},{"name":"cloud","slug":"cloud","permalink":"http://blog.liurenjie.top/tags/cloud/"},{"name":"ejs","slug":"ejs","permalink":"http://blog.liurenjie.top/tags/ejs/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.liurenjie.top/tags/hexo/"}]},{"title":"hexo添加个性化插件","slug":"hexo2018-05-26-1","date":"2018-05-26T00:00:00.000Z","updated":"2018-06-04T03:11:02.918Z","comments":true,"path":"posts/d2b05ff5.html","link":"","permalink":"http://blog.liurenjie.top/posts/d2b05ff5.html","excerpt":"原创、转载标签在markdown文章头部加上type类型创建type.ejs123456789&lt;% if (post.type &amp;&amp; post.type.length) &#123; %&gt;&lt;div class=&quot;article-type&quot;&gt; &lt;% if (post.type == &apos;Y&apos;) &#123; %&gt; &lt;span class=&quot;label label-success&quot; style=&quot;float: left;padding: 3px 5px 3px 5px;margin-top: 2px;&quot;&gt;原创&lt;/span&gt; &lt;% &#125; else if (post.type == &apos;N&apos;) &#123; %&gt; &lt;span class=&quot;label label-error&quot; style=&quot;float: left;padding: 3px 5px 3px 5px;margin-top: 2px;&quot;&gt;转载&lt;/span&gt; &lt;% &#125; %&gt;&lt;/div&gt;&lt;% &#125; %&gt;","text":"原创、转载标签在markdown文章头部加上type类型创建type.ejs123456789&lt;% if (post.type &amp;&amp; post.type.length) &#123; %&gt;&lt;div class=&quot;article-type&quot;&gt; &lt;% if (post.type == &apos;Y&apos;) &#123; %&gt; &lt;span class=&quot;label label-success&quot; style=&quot;float: left;padding: 3px 5px 3px 5px;margin-top: 2px;&quot;&gt;原创&lt;/span&gt; &lt;% &#125; else if (post.type == &apos;N&apos;) &#123; %&gt; &lt;span class=&quot;label label-error&quot; style=&quot;float: left;padding: 3px 5px 3px 5px;margin-top: 2px;&quot;&gt;转载&lt;/span&gt; &lt;% &#125; %&gt;&lt;/div&gt;&lt;% &#125; %&gt;然后在article.ejs中调用12345678910111213&lt;% if (post.link || post.title) &#123; %&gt; &lt;header class=&quot;article-header&quot;&gt; &lt;%- partial(&apos;post/title&apos;, &#123; class_name: &apos;article-title&apos; &#125;) %&gt; &lt;% if (post.layout != &apos;page&apos;) &#123; %&gt; &lt;div class=&quot;article-meta&quot;&gt; &lt;%- partial(&apos;post/type&apos;) %&gt; &lt;%- partial(&apos;post/date&apos;, &#123; class_name: &apos;article-date&apos;, date_format: null &#125;) %&gt; &lt;%- partial(&apos;post/category&apos;) %&gt; &lt;%- partial(&apos;post/readcount&apos;) %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/header&gt; &lt;% &#125; %&gt;打赏功能本网站打赏功能来自于 畅言 网。站点访问次数总访问 6192724 次, 您是本站第 377842 位访问者来源 不蒜子文章浏览次数跳转到文章浏览次数","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.liurenjie.top/categories/hexo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"},{"name":"ejs","slug":"ejs","permalink":"http://blog.liurenjie.top/tags/ejs/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.liurenjie.top/tags/hexo/"},{"name":"css","slug":"css","permalink":"http://blog.liurenjie.top/tags/css/"},{"name":"html","slug":"html","permalink":"http://blog.liurenjie.top/tags/html/"}]},{"title":"2018-04-20 IntelliJ IDEA 2018.1.1 激活破解方法","slug":"java2018-04-20-1","date":"2018-04-20T17:16:29.000Z","updated":"2018-06-01T09:06:20.075Z","comments":true,"path":"posts/de16cbc4.html","link":"","permalink":"http://blog.liurenjie.top/posts/de16cbc4.html","excerpt":"方法一原文在打开的License Activation窗口中选择“License server”， 在输入框输入下面的网址：http://idea.codebeta.cn （感谢Rachelsalaheiyo提供）或者http://idea.imsxm.com/点击：Activate即可激活。PS：激活时间不能保证，先用吧！","text":"方法一原文在打开的License Activation窗口中选择“License server”， 在输入框输入下面的网址：http://idea.codebeta.cn （感谢Rachelsalaheiyo提供）或者http://idea.imsxm.com/点击：Activate即可激活。PS：激活时间不能保证，先用吧！方法二这里写链接内容JetBrains 授权服务器(License Server):http://idea.imsxm.comhttp://www.activejetbrains.ga (2017.3.4以上紧急车道其他车辆请避让)使用方法：激活时选择License server 填入http://idea.imsxm.com 点击Active即可 :taikaixin: 。how-to-active: when active,type the url in License server address input box,and then press the Active button:)Banned?create yourselfs license server[link]若资金允许，请点击https://www.jetbrains.com/idea/buy/购买正版if u r rich,please buy the ide on https://www.jetbrains.com/idea/buy/授权服务器理论支持的版本有(supported version)：123456789101112IntelliJ IDEA 7.0 或更高(or above)ReSharper 3.1 或更高ReSharper Cpp 1.0 或更高dotTrace 5.5 或更高dotMemory 4.0 或更高dotCover 1.0 或更高RubyMine 1.0 或更高PyCharm 1.0 或更高WebStorm 1.0 或更高PhpStorm 1.0 或更高AppCode 1.0 或更高CLion 1.0 或更高方法三五分钟搭建Jetbrains家族IDE授权服务器作为Java码农，IntelliJ IDEA可谓是N0.1的开发环境了，对框架的支持，界面，插件都是比较方便的，大大加快了开发的速度以及开发的乐趣，酷炫的界面也能大大的装一个逼虽然这里教大家搭建授权服务器，但是月入1狗的同志还是支持一下人家嘛，毕竟都是码农。Idea购买地址：https://www.jetbrains.com/idea/buy/对于暂时经济不宽裕的同学，你可能需要一款支持Jetbrains家族IDE授权服务器。比较明智的选择是Google一台即可，有能力的同学不妨尝试自行架设，这也就是本文的目的啦。喝水不忘挖井人，在此向服务器软件的作者Lanyu表示衷心的感谢。服务器下载地址：点击我(V1.3)V1.4:下载地址：https://mega.nz/#!Hs4CEbRR!FteOJmJ0AfuLvTUFs3dn9xH6eESm3io2BZ5neIXTQds解压密码:3415E428磁力链接:magnet:?xt=urn:btih:ED1FA379ECBD34D13CB7D14B0C2B024986A6FC79&amp;dn=IntelliJIDEALicenseServer(v1.4).tar种子：http://ww1.sinaimg.cn/large/871e88b0gy1ffwqq566kxj205k05kq2y.jpg(保存到本地,以zip格式打开)V1.6下载地址：https://mega.nz/#!f4A2WQRB!fMNbcuSt0YxrjXclW81_GZol-g6dURrO1htqXPMYa8Q链接: https://pan.baidu.com/s/1dFS9DaL 密码: xxc2下载后有很多版本，如果你电脑是windows，对应的使用windows后缀的，Mac OS使用darwin后缀，os x 10.12上需要把upx加的壳脱掉，用高点的端口12brew install upxupx -d IntelliJIDEALicenseServer_darwin_amd64Ubuntu/centos等没有对应后缀的用linux，要注意区别32/64位,amd64是64位，386是32位。windows下就不介绍了，点击就可以用，如果需要自定义参数，请根据采用命令行带参数运行,，参数如下：1234-l 指定绑定监听到哪个IP(私人用)-u 用户名参数，当未设置-u参数，且计算机用户名为^[a-zA-Z0-9]+$时，使用计算机用户名作为idea用户名-p 参数，用于指定监听的端口-prolongationPeriod 指定过期时间参数PS:若在程序工作目录中存在IntelliJIDEALicenseServer.html文件，则返回IntelliJIDEALicenseServer.html中的内容到用户浏览器。接下来，介绍如何部署到Linux服务器上，首先将IntelliJIDEALicenseServer_linux_amd64上传到任意目录，我这里是root目录，先将名字改了，太长了123mv IntelliJIDEALicenseServer_linux_amd64 IdeaServerchmod +x IdeaServer/root/IdeaServer -p 1024 -prolongationPeriod 999999999999默认运行会出现以下信息，则为成功。如果要后台运行，请使用nohup命令我们可以通过nohup的方式实现后台运行12cd /root/ nohup ./IdeaServer -p 1024 -prolongationPeriod 999999999999 &amp;gt;&amp;gt; idea.out 2&amp;gt;&amp;amp;1 &amp;amp;也可以通过supervisor实现守护进程，自启动。命令如下1234567vi /etc/supervisord.conf#添加以下内容[program:idea-server]command = /root/IdeaServer -p 1024 -u imsxm.com -prolongationPeriod 999999999 -l 127.0.0.1autostart=trueautorestart=truestartsecs=3接下来，将自己的域名采用nginx反向代理过来,nginx如以下配置123456789101112131415161718192021222324server &#123; listen 80; server_name license.liurenjie.top; rewrite ^ https://$http_host$request_uri? permanent; # force redirect http to https &#125; server &#123; listen 443; server_name license.liurenjie.top; ssl on; root html; index index.html index.htm; ssl_certificate cert/214610193010989.pem; ssl_certificate_key cert/214610193010989.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:1017; &#125; &#125;这样就大功告成了！自己搭建的：https://license.liurenjie.top如果有什么问题，可以留言反馈。","categories":[{"name":"破解","slug":"破解","permalink":"http://blog.liurenjie.top/categories/破解/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://blog.liurenjie.top/tags/idea/"},{"name":"破解","slug":"破解","permalink":"http://blog.liurenjie.top/tags/破解/"}]},{"title":"深入理解乐观锁与悲观锁","slug":"mysql2018-04-18-1","date":"2018-04-18T15:09:03.000Z","updated":"2018-06-01T06:43:51.593Z","comments":true,"path":"posts/9ac7da4f.html","link":"","permalink":"http://blog.liurenjie.top/posts/9ac7da4f.html","excerpt":"在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。下面来分别学习一下悲观锁和乐观锁。","text":"在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。下面来分别学习一下悲观锁和乐观锁。悲观锁在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic ConcurrencyControl，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）在数据库中，悲观锁的流程如下：在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。MySQL InnoDB中使用悲观锁要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。setautocommit=0;12345678910//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work;上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQLInnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。优点与不足悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数乐观锁在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic ConcurrencyControl，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。使用版本号实现乐观锁使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。查询出商品信息select (status,status,version) from t_goods where id=#{id}根据商品信息生成订单修改商品status为2123update t_goods set status=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;;优点与不足乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"},{"name":"lock","slug":"lock","permalink":"http://blog.liurenjie.top/tags/lock/"}]},{"title":"前端图片压缩上传(纯js的质量压缩，非长宽压缩)","slug":"javascript2018-04-17-1","date":"2018-04-17T16:04:51.000Z","updated":"2018-06-01T06:43:51.597Z","comments":true,"path":"posts/2fc63518.html","link":"","permalink":"http://blog.liurenjie.top/posts/2fc63518.html","excerpt":"此demo为大于1M对图片进行压缩上传若小于1M则原图上传，可以根据自己实际需求更改。demo源码如下：","text":"此demo为大于1M对图片进行压缩上传若小于1M则原图上传，可以根据自己实际需求更改。demo源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;XMLHttpRequest上传文件&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* 三个参数 file：一个是文件(类型是图片格式)， w：一个是文件压缩的后宽度，宽度越小，字节越小 objDiv：一个是容器或者回调函数 photoCompress() */ function photoCompress(file,w,objDiv)&#123; var ready=new FileReader(); /*开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.*/ ready.readAsDataURL(file); ready.onload=function()&#123; var re=this.result; canvasDataURL(re,w,objDiv) &#125; &#125; function canvasDataURL(path, obj, callback)&#123; var img = new Image(); img.src = path; img.onload = function()&#123; var that = this; // 默认按比例压缩 var w = that.width, h = that.height, scale = w / h; w = obj.width || w; h = obj.height || (w / scale); var quality = 0.7; // 默认图片质量为0.7 //生成canvas var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); // 创建属性节点 var anw = document.createAttribute(\"width\"); anw.nodeValue = w; var anh = document.createAttribute(\"height\"); anh.nodeValue = h; canvas.setAttributeNode(anw); canvas.setAttributeNode(anh); ctx.drawImage(that, 0, 0, w, h); // 图像质量 if(obj.quality &amp;&amp; obj.quality &lt;= 1 &amp;&amp; obj.quality &gt; 0)&#123; quality = obj.quality; &#125; // quality值越小，所绘制出的图像越模糊 var base64 = canvas.toDataURL('image/jpeg', quality); // 回调函数返回base64的值 callback(base64); &#125; &#125; /** * 将以base64的图片url数据转换为Blob * @param urlData * 用url方式表示的base64图片数据 */ function convertBase64UrlToBlob(urlData)&#123; var arr = urlData.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123;type:mime&#125;); &#125; var xhr; //上传文件方法 function UpladFile() &#123; var fileObj = document.getElementById(\"file\").files[0]; // js 获取文件对象 var url = \"后台图片上传接口\"; // 接收上传文件的后台地址 var form = new FormData(); // FormData 对象 if(fileObj.size/1024 &gt; 1025) &#123; //大于1M，进行压缩上传 photoCompress(fileObj, &#123; quality: 0.2 &#125;, function(base64Codes)&#123; //console.log(\"压缩后：\" + base.length / 1024 + \" \" + base); var bl = convertBase64UrlToBlob(base64Codes); form.append(\"file\", bl, \"file_\"+Date.parse(new Date())+\".jpg\"); // 文件对象 xhr = new XMLHttpRequest(); // XMLHttpRequest 对象 xhr.open(\"post\", url, true); //post方式，url为服务器请求地址，true 该参数规定请求是否异步处理。 xhr.onload = uploadComplete; //请求完成 xhr.onerror = uploadFailed; //请求失败 xhr.upload.onprogress = progressFunction;//【上传进度调用方法实现】 xhr.upload.onloadstart = function()&#123;//上传开始执行方法 ot = new Date().getTime(); //设置上传开始时间 oloaded = 0;//设置上传开始时，以上传的文件大小为0 &#125;; xhr.send(form); //开始上传，发送form数据 &#125;); &#125;else&#123; //小于等于1M 原图上传 form.append(\"file\", fileObj); // 文件对象 xhr = new XMLHttpRequest(); // XMLHttpRequest 对象 xhr.open(\"post\", url, true); //post方式，url为服务器请求地址，true 该参数规定请求是否异步处理。 xhr.onload = uploadComplete; //请求完成 xhr.onerror = uploadFailed; //请求失败 xhr.upload.onprogress = progressFunction;//【上传进度调用方法实现】 xhr.upload.onloadstart = function()&#123;//上传开始执行方法 ot = new Date().getTime(); //设置上传开始时间 oloaded = 0;//设置上传开始时，以上传的文件大小为0 &#125;; xhr.send(form); //开始上传，发送form数据 &#125; &#125; //上传成功响应 function uploadComplete(evt) &#123; //服务断接收完文件返回的结果 var data = JSON.parse(evt.target.responseText); if(data.success) &#123; alert(\"上传成功！\"); &#125;else&#123; alert(\"上传失败！\"); &#125; &#125; //上传失败 function uploadFailed(evt) &#123; alert(\"上传失败！\"); &#125; //取消上传 function cancleUploadFile()&#123; xhr.abort(); &#125; //上传进度实现方法，上传过程中会频繁调用该方法 function progressFunction(evt) &#123; var progressBar = document.getElementById(\"progressBar\"); var percentageDiv = document.getElementById(\"percentage\"); // event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0 if (evt.lengthComputable) &#123;// progressBar.max = evt.total; progressBar.value = evt.loaded; percentageDiv.innerHTML = Math.round(evt.loaded / evt.total * 100) + \"%\"; &#125; var time = document.getElementById(\"time\"); var nt = new Date().getTime();//获取当前时间 var pertime = (nt-ot)/1000; //计算出上次调用该方法时到现在的时间差，单位为s ot = new Date().getTime(); //重新赋值时间，用于下次计算 var perload = evt.loaded - oloaded; //计算该分段上传的文件大小，单位b oloaded = evt.loaded;//重新赋值已上传文件大小，用以下次计算 //上传速度计算 var speed = perload/pertime;//单位b/s var bspeed = speed; var units = 'b/s';//单位名称 if(speed/1024&gt;1)&#123; speed = speed/1024; units = 'k/s'; &#125; if(speed/1024&gt;1)&#123; speed = speed/1024; units = 'M/s'; &#125; speed = speed.toFixed(1); //剩余时间 var resttime = ((evt.total-evt.loaded)/bspeed).toFixed(1); time.innerHTML = '，速度：'+speed+units+'，剩余时间：'+resttime+'s'; if(bspeed==0) time.innerHTML = '上传已取消'; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;progress id=\"progressBar\" value=\"0\" max=\"100\" style=\"width: 300px;\"&gt;&lt;/progress&gt;&lt;span id=\"percentage\"&gt;&lt;/span&gt;&lt;span id=\"time\"&gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;input type=\"file\" id=\"file\" name=\"myfile\" accept=\"image/x-png, image/jpg, image/jpeg, image/gif\"/&gt;&lt;input type=\"button\" onclick=\"UpladFile()\" value=\"上传\" /&gt;&lt;input type=\"button\" onclick=\"cancleUploadFile()\" value=\"取消\" /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"},{"name":"图片压缩","slug":"图片压缩","permalink":"http://blog.liurenjie.top/tags/图片压缩/"}]},{"title":"https nginx配置文件","slug":"nginx2018-03-30-1","date":"2018-03-30T11:01:56.000Z","updated":"2018-06-01T06:43:51.595Z","comments":true,"path":"posts/755145a9.html","link":"","permalink":"http://blog.liurenjie.top/posts/755145a9.html","excerpt":"安装nginx","text":"安装nginx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576user www www;worker_processes 1; #设置值和CPU核心数一致error_log /usr/local/webserver/nginx/logs/nginx_error.log crit; #日志位置和日志级别pid /usr/local/webserver/nginx/nginx.pid;#Specifies the value for maximum file descriptors that can be opened by this process.worker_rlimit_nofile 65535;events&#123; use epoll; worker_connections 65535;&#125;http&#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" $http_x_forwarded_for';#charset gb2312; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 8m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #下面是server虚拟主机的配置 server &#123; listen 80;#监听端口 server_name www.liurenjie.top;#domain rewrite ^ https://$http_host$request_uri? permanent; # force redirect http to https # rewrite 301 https://$server_name$request_uri; &#125; server &#123;# listen 80; listen 443; server_name www.liurenjie.top; ssl on; root html; index index.html index.htm; ssl_certificate cert/ssl.pem; ssl_certificate_key cert/ssl.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; # root html; # index index.html index.htm; proxy_pass http://127.0.0.1:9000; #项目地址 &#125; &#125;&#125;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/tags/nginx/"}]},{"title":"将jar包安装到本地repository中的命令","slug":"java2018-03-28-1","date":"2018-03-28T16:34:16.000Z","updated":"2018-06-01T06:43:51.586Z","comments":true,"path":"posts/49141bf6.html","link":"","permalink":"http://blog.liurenjie.top/posts/49141bf6.html","excerpt":"","text":"mvn install:install-file -Dfile=my-jar.jar -DgroupId=org.richard -DartifactId=my-jar -Dversion=1.0 -Dpackaging=jarmvn install:install-file-Dfile=jar包的位置-DgroupId=上面的groupId-DartifactId=上面的artifactId-Dversion=上面的version","categories":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/categories/maven/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/tags/maven/"}]},{"title":"Linux 下后台运行程序，查看和关闭后台运行程序","slug":"linux2018-03-27-2","date":"2018-03-27T14:03:48.000Z","updated":"2018-06-01T08:51:30.347Z","comments":true,"path":"posts/4766fec9.html","link":"","permalink":"http://blog.liurenjie.top/posts/4766fec9.html","excerpt":"运行.sh文件直接用./sh 文件就可以运行，但是如果想后台运行，即使关闭当前的终端也可以运行的话，需要nohup命令和&amp;命令。&amp;命令功能：加在一个命令的最后，可以把这个命令放在后台执行nohup命令功能：不挂断的运行命令","text":"运行.sh文件直接用./sh 文件就可以运行，但是如果想后台运行，即使关闭当前的终端也可以运行的话，需要nohup命令和&amp;命令。&amp;命令功能：加在一个命令的最后，可以把这个命令放在后台执行nohup命令功能：不挂断的运行命令查看当前后台运行的命令​ 有两个命令可以用，jobs和ps,区别是jobs用于查看当前终端后台运行的任务，换了终端就看不到了。而ps命令用于查看瞬间进程的动态，可以看到别的终端运行的后台进程。jobs命令功能：查看当前终端后台运行的任务jobs -l选项可显示当前终端所有任务的PID，jobs的状态可以是running，stopped，Terminated。+ 号表示当前任务，- 号表示后一个任务。ps命令功能：查看当前的所有进程1ps -aux | grep \"test.sh\" #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分关闭当前后台运行的命令kill命令：结束进程通过jobs命令查看jobnum，然后执行 kill %jobnum通过ps命令查看进程号PID，然后执行 kill %PID如果是前台进程的话，直接执行 Ctrl+c 就可以终止了前后台进程的切换与控制fg 命令功能：将后台中的命令调至前台继续运行如果后台中有多个命令，可以先用jobs查看jobnun，然后用 fg %jobnum 将选中的命令调出。Ctrl + z 命令功能：将一个正在前台执行的命令放到后台，并且处于暂停状态bg命令功能：将一个在后台暂停的命令，变成在后台继续执行如果后台中有多个命令，可以先用jobs查看jobnum，然后用 bg %jobnum 将选中的命令调出继续执行。​","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://blog.liurenjie.top/tags/shell/"},{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/tags/linux/"}]},{"title":"sh_脚本语法","slug":"linux2018-03-27-1","date":"2018-03-27T14:01:48.000Z","updated":"2018-06-01T05:52:18.130Z","comments":true,"path":"posts/ea2f6d55.html","link":"","permalink":"http://blog.liurenjie.top/posts/ea2f6d55.html","excerpt":"介绍：开头程序必须以下面的行开始（必须方在文件的第一行）：1#!/bin/sh1符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。当编写脚本完成时，如果要执行该脚本，还必须使其可执行。要使编写脚本可执行：编译 chmod +x filename 这样才能用./filename 来运行","text":"介绍：开头程序必须以下面的行开始（必须方在文件的第一行）：1#!/bin/sh1符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。当编写脚本完成时，如果要执行该脚本，还必须使其可执行。要使编写脚本可执行：编译 chmod +x filename 这样才能用./filename 来运行2 注释在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。3 变量在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：1#!/bin/sh对变量赋值：1234567a=”hello world” # 现在打印变量a的内容：echo “A is:”echo $有时候变量名很容易与其他文字混淆，比如：123num=2echo “this is the $numnd”这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：123num=2echo “this is the $&#123;num&#125;nd”这将打印： this is the 2nd4 环境变量由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。5 Shell命令和流程控制在shell脚本中可以使用三类命令：1) Unix 命令:虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。常用命令语法及功能echo “some text”: 将文字内容打印在屏幕上ls: 文件列表wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数cp sourcefile destfile: 文件拷贝mv oldname newname : 重命名文件或移动文件rm file: 删除文件grep ‘pattern’ file: 在文件内搜索字符串比如：grep ’searchstring’ file.txtcut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令cat file.txt: 输出文件内容到标准输出设备（屏幕）上file somefile: 得到文件类型read var: 提示用户输入，并将输入赋值给变量sort file.txt: 对file.txt文件中的行进行排序uniq: 删除文本文件中出现的行列比如： sort file.txt | uniqexpr: 进行数学运算Example: add 2 and 3expr 2 “+” 3find: 搜索文件比如：根据文件名搜索find . -name filename –printtee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfilebasename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tuxdirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /binhead file: 打印文本文件开头几行tail file : 打印文本文件末尾几行sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus替换为 LinuxFocus ：cat text.file | sed ’s/linuxfocus/LinuxFocus/’ &gt;newtext.fileawk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。catfile.txt | awk -F, ‘{print 1“,”1“,”3}’这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerryMiller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA2) 概念: 管道, 重定向和 backtick这些不是系统命令，但是他们真的很重要。管道 (|) 将一个命令的输出作为另外一个命令的输入。grep “hello” file.txt | wc –l在file.txt中搜索包含有”hello”的行并计算其行数。在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。123&gt; 写入文件并覆盖旧文件&gt;&gt; 加到文件的尾部，保留旧文件内容。反短斜线使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。命令：1find . -mtime -1 -type f –print1用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下linux 脚本：12345#!/bin/sh# The ticks are backticks (`) not normal quotes (‘):tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print`3) 流程控制1.if“if” 表达式如果条件为真则执行then后面的部分：12345678910111213if ….; then….elif ….; then….Else….fi大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。[ -f “somefile” ] ：判断是否是一个文件[ -x “/bin/ls” ] ：判断/bin/ls是否存在并有可执行权限[ -n “var&quot;]：判断var”]：判断var变量是否有值[ “a&quot;=&quot;a&quot;=&quot;b” ] ：判断a和a和b是否相等执行man test可以查看所有测试表达式可以比较和判断的类型。直接执行以下脚本：12345678910#!/bin/shif [ \"$SHELL\" = \"/bin/bash\" ]; thenecho “your login shell is the bash (bourne again shell)”elseecho “your login shell is not bash but $SHELL”Fi12345678910变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。快捷操作符熟悉C语言的朋友可能会很喜欢下面的表达式：1[ -f \"/etc/shadow\" ] &amp;&amp; echo “This computer uses shadow passwors”1这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：123456789#!/bin/shmailfolder=/var/spool/mail/james[ -r \"$mailfolder\" ]‘ ‘&#123; echo “Can not read $mailfolder” ; exit 1; &#125;echo “$mailfolder has mail from:”grep “^From ” $mailfolder123456789该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：打印错误信息退出程序我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。以上给您讲解的是Linux脚本编写的基础知识。","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://blog.liurenjie.top/tags/shell/"},{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/tags/linux/"},{"name":"sh","slug":"sh","permalink":"http://blog.liurenjie.top/tags/sh/"}]},{"title":"Java8 Stream API介绍","slug":"java2018-03-27-3","date":"2018-03-27T13:55:34.000Z","updated":"2018-06-01T03:59:45.206Z","comments":true,"path":"posts/3cadc7b.html","link":"","permalink":"http://blog.liurenjie.top/posts/3cadc7b.html","excerpt":"Stream API是Java8中处理集合的关键组件，提供了各种丰富的函数式操作。Stream的创建任何集合都可以转换为Stream：1234567891011121314//数组 String[] strArr = new String[]&#123;\"aa\",\"bb\",\"cc\"&#125;; Stream&lt;String&gt; streamArr = Stream.of(strArr); Stream&lt;String&gt; streamArr2 = Arrays.stream(strArr); //集合 List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; streamList = list.stream(); Stream&lt;String&gt; streamList2 = list.parallelStream();//并行执行 ... //generator 生成无限长度的stream Stream.generate(Math::random); // iterate 也是生成无限长度的Stream，其元素的生成是重复对给定的种子值调用函数来生成的 Stream.iterate(1, item -&gt; item + 1)","text":"Stream API是Java8中处理集合的关键组件，提供了各种丰富的函数式操作。Stream的创建任何集合都可以转换为Stream：1234567891011121314//数组 String[] strArr = new String[]&#123;\"aa\",\"bb\",\"cc\"&#125;; Stream&lt;String&gt; streamArr = Stream.of(strArr); Stream&lt;String&gt; streamArr2 = Arrays.stream(strArr); //集合 List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; streamList = list.stream(); Stream&lt;String&gt; streamList2 = list.parallelStream();//并行执行 ... //generator 生成无限长度的stream Stream.generate(Math::random); // iterate 也是生成无限长度的Stream，其元素的生成是重复对给定的种子值调用函数来生成的 Stream.iterate(1, item -&gt; item + 1)Stream的简单使用Stream的使用分为两种类型：Intermediate,一个Stream可以调用0到多个Intermediate类型操作，每次调用会对Stream做一定的处理，返回一个新的Stream，这类操作都是惰性化的（lazy），就是说，并没有真正开始流的遍历。常用操作：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallelTerminal,一个Stream只能执行一次terminal 操作，而且只能是最后一个操作，执行terminal操作之后，Stream就被消费掉了，并且产生一个结果。常用操作：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny使用示例：1234567891011121314151617181920212223/********** Intermediate **********///filter 过滤操作streamArr.filter(str -&gt; str.startsWith(\"a\"));//map 遍历和转换操作streamArr.map(String::toLowerCase);//flatMap 将流展开List&lt;String&gt; list1 = new ArrayList&lt;&gt;();list1.add(\"aa\");list1.add(\"bb\");List&lt;String&gt; list2 = new ArrayList&lt;&gt;();list2.add(\"cc\");list2.add(\"dd\");Stream.of(list1,list2).flatMap(str -&gt; str.stream()).collect(Collectors.toList()); //limit 提取子流streamArr.limit(1);//skip 跳过streamArr.skip(1);//peek 产生相同的流，支持每个元素调用一个函数streamArr.peek(str - &gt; System.out.println(\"item:\"+str));//distinct 去重Stream.of(\"aa\",\"bb\",\"aa\").distinct();//sorted 排序Stream.of(\"aaa\",\"bb\",\"c\").sorted(Comparator.comparing(String::length).reversed());//parallel 转为并行流,谨慎使用streamArr.parallel();12345678910111213141516171819202122232425262728293031/********** Terminal **********///forEachstreamArr.forEach(System.out::println);//forEachOrdered 如果希望顺序执行并行流，请使用该方法streamArr.parallel().forEachOrdered(System.out::println);//toArray 收集到数组中streamArr.filter(str -&gt; str.startsWith(\"a\")).toArray(String[]::new);//reduce 聚合操作streamArr.reduce((str1,str2) -&gt; str1+str2);//collect 收集到List中streamArr.collect(Collectors.toList());//collect 收集到Set中streamArr.collect(Collectors.toSet());//min 取最小值？IntStream.of(1,2,3,4).min();Stream.of(arr).min(String::compareTo);//max 取最大值？IntStream.of(1,2,3,4).max();Stream.of(arr).max(String::compareTo);//count 计算总量？streamArr.count();//anyMatch 判断流中是否含有匹配元素boolean hasMatch = streamArr.anyMatch(str -&gt; str.startsWith(\"a\"));//allMatch 判断流中是否全部匹配boolean hasMatch = streamArr.allMatch(str -&gt; str.startsWith(\"a\"));//noneMatch 判断流中是否全部不匹配boolean hasMatch = streamArr.noneMatch(str -&gt; str.startsWith(\"a\"));//findFirst 找到第一个就返回streamArr.filter(str -&gt; str.startsWith(\"a\")).findFirst();//findAny 找到任意一个就返回streamArr.filter(str -&gt; str.startsWith(\"a\")).findAny();收集结果collect操作主要用于将stream中的元素收集到一个集合容器中，collect函数的定义如下：123&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);第一个参数Supplier用于生成一个目标集合容器类型的实例；函数BiConsumer1234Set&lt;String&gt; result = Stream.of(\"aa\", \"bb\", \"cc\", \"aa\").collect( () -&gt; new HashSet&lt;String&gt;(), (set, item) -&gt; set.add(item), (set, subSet) -&gt; set.addAll(subSet));以上写法可以使用操作符“::”简化，语法如下：对象：：实例方法类：：静态方法类：：实例方法1234Set&lt;String&gt; result = Stream.of(\"aa\", \"bb\", \"cc\", \"aa\").collect( HashSet::new, HashSet::add, HashSet::addAll);java.util.stream.Collectors类中已经预定义好了toList，toSet，toMap，toCollection等方便使用的方法，所以以上代码还可以简化如下：1Set&lt;String&gt; result2 = Stream.of(\"aa\", \"bb\", \"cc\", \"aa\").collect(Collectors.toSet());将结果收集到Map中，Collectors.toMap方法的两个重载定义如下:keyMapper函数用于从实例T中得到一个K类型的Map key;valueMapper函数用于从实例T中得到一个U类型的Map value;mergeFunction函数用于处理key冲突的情况，默认为throwingMerger(),抛出IllegalStateException异常；mapSupplier函数用于生成一个Map实例；1234567891011121314151617public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper) &#123; return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new); &#125;public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier) &#123; BiConsumer&lt;M, T&gt; accumulator = (map, element) -&gt; map.merge(keyMapper.apply(element), valueMapper.apply(element), mergeFunction); return new CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID); &#125;假设有一个User实体类，有方法getId(),getName(),getAge()等方法，现在想要将User类型的流收集到一个Map中，示例如下：123Stream&lt;User&gt; userStream = Stream.of(new User(0, \"张三\", 18), new User(1, \"张四\", 19), new User(2, \"张五\", 19), new User(3, \"老张\", 50));Map&lt;Integer, User&gt; userMap = userSteam.collect(Collectors.toMap(User::getId, item -&gt; item));假设要得到按年龄分组的Map12345Map&lt;Integer, List&lt;User&gt;&gt; ageMap = userStream.collect(Collectors.toMap(User::getAge, Collections::singletonList, (a, b) -&gt; &#123; List&lt;User&gt; resultList = new ArrayList&lt;&gt;(a); resultList.addAll(b); return resultList; &#125;));这种写法虽然可以实现分组功能，但是太过繁琐，好在Collectors中提供了groupingBy方法，可以用来实现该功能，简化后写法如下：1Map&lt;Integer, List&lt;User&gt;&gt; ageMap2 = userStream.collect(Collectors.groupingBy(User::getAge));类似的，Collectors中还提供了partitioningBy方法，接受一个Predicate函数，该函数返回boolean值，用于将内容分为两组。假设User实体中包含性别信息getSex()，可以按如下写法将userStream按性别分组：1Map&lt;Boolean, List&lt;User&gt;&gt; sexMap = userStream.collect(Collectors.partitioningBy(item -&gt; item.getSex() &gt; 0));Collectors中还提供了一些对分组后的元素进行downStream处理的方法：counting方法返回所收集元素的总数；summing方法会对元素求和；maxBy和minBy会接受一个比较器，求最大值，最小值；mapping函数会应用到downstream结果上，并需要和其他函数配合使用；1234567Map&lt;Integer, Long&gt; sexCount = userStream.collect(Collectors.groupingBy(User::getSex,Collectors.counting())); Map&lt;Integer, Integer&gt; ageCount = userStream.collect(Collectors.groupingBy(User::getSex,Collectors.summingInt(User::getAge)));Map&lt;Integer, Optional&lt;User&gt;&gt; ageMax = userStream.collect(Collectors.groupingBy(User::getSex,Collectors.maxBy(Comparator.comparing(User::getAge))));Map&lt;Integer, List&lt;String&gt;&gt; nameMap = userStream.collect(Collectors.groupingBy(User::getSex,Collectors.mapping(User::getName,Collectors.toList())));以上为各种collectors操作的使用案例。Optional类型Optional 是对T类型对象的封装，它不会返回null，因而使用起来更加安全。ifPresent方法接受一个函数作为形参，如果存在当前Optinal存在值则使用当前值调用函数，否则不做任何操作，示例如下：12Optional&lt;T&gt; optional = ... optional.ifPresent(v -&gt; results.add(v));orElse方法，orElseGet方法，当值不存在时产生一个替代值，示例如下：12String result = optional.orElse(\"defaultValue\"); String result = optional.orElseGet(() -&gt; getDefalutValue());可以使用Optional.of()方法和Optional.empty()方法来创建一个Optional类型对象，示例如下：1a - b &gt; 0 ? Optional.of(a - b) : Optional.empty();函数式接口Steam.filter方法接受一个Predicate函数作为入参，该函数返回一个boolean类型，下图为Stream和COllectors方法参数的函数式接口:总结Stream的处理总会在最后的Terminal操作才会真正执行;没有内部存储，也不能改变使用到的数据源，每次操作都会生成一个新的流；并行流使用fork/join 池来实现，对于非CPU密集型任务，需要谨慎使用；相对于循环遍历操作代码可读性更高；","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://blog.liurenjie.top/tags/lambda/"},{"name":"java8","slug":"java8","permalink":"http://blog.liurenjie.top/tags/java8/"}]},{"title":"spring boot 学习(十二)拦截器实现IP黑名单","slug":"java2018-03-27-2","date":"2018-03-27T13:47:26.000Z","updated":"2018-06-01T03:59:45.179Z","comments":true,"path":"posts/97741006.html","link":"","permalink":"http://blog.liurenjie.top/posts/97741006.html","excerpt":"拦截器实现IP黑名单前言最近一直在搞 Hexo+GithubPage 搭建个人博客，所以没怎么进行 SpringBoot 的学习。所以今天就将上次的”?秒防刷新”进行了一番修改。上次是采用注解加拦截器(@Aspect)来实现功能的。但是，如果需求是一个全局的拦截器对于大部分URL都进行拦截的话，自己一个个加显然是不可能的。而且上次的拦截器对于Controller的参数有所要求，在实际他人引用总是显得不方便。所以，这次使用了继承HandlerInterceptor来实现拦截器。","text":"拦截器实现IP黑名单前言最近一直在搞 Hexo+GithubPage 搭建个人博客，所以没怎么进行 SpringBoot 的学习。所以今天就将上次的”?秒防刷新”进行了一番修改。上次是采用注解加拦截器(@Aspect)来实现功能的。但是，如果需求是一个全局的拦截器对于大部分URL都进行拦截的话，自己一个个加显然是不可能的。而且上次的拦截器对于Controller的参数有所要求，在实际他人引用总是显得不方便。所以，这次使用了继承HandlerInterceptor来实现拦截器。功能需求对于项目中某类URL进行拦截，若用户在短时间内大量访问该链接，则将用户IP列入黑名单，禁止用户访问网页。(同时，可以使用@Async来创建定时任务帮用户解禁。)准备？秒防刷新的业务逻辑博客地址 : http://blog.csdn.net/u011244202/article/details/54783337项目参考地址 : https://github.com/FunriLy/springboot-study/tree/master/%E6%A1%88%E4%BE%8B5SpringBoot+Druid+MyBatis博客地址 : http://blog.csdn.net/u011244202/article/details/54709060项目参考地址 : https://github.com/FunriLy/springboot-study/tree/master/%E6%A1%88%E4%BE%8B1知识记录Spring 的拦截器 HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。配置拦截器也很简单，Spring 为此提供了基础类WebMvcConfigurerAdapter ，我们只需要重写addInterceptors 方法添加注册拦截器。实现自定义拦截器只需要3步：1、创建我们自己的拦截器类并实现 HandlerInterceptor 接口。2、创建一个 Java 类继承 WebMvcConfigurerAdapter，并重写 addInterceptors 方法。3、实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。正式开工IP工具类由于不清楚用户代理，最好能使用一个工具类来来获取用户真实IP。这个Google就能找到，我就不贴代码了。数据库我使用的是MySQL数据库，持久层框架为MyBatis。具体可参考”准备”步骤。我在”myboot”数据库中创建一张表”blaclist”，属性如下：实体类123456789101112131415public class BlackList &#123; private int id; //记录的id private String ip; //用户真实IP private Date iptime; // 日期类型，格式：yyyy-MM-dd HH:mm:ss IP被锁时间 //构造器 public BlackList() &#123; &#125; public BlackList(String ip, Date iptime) &#123; this.ip = ip; this.iptime = iptime; &#125; // get &amp;&amp; set 方法&#125;Dao层注意XML配置与对应实体配置(省略)。1234567@Mapperpublic interface BlackListDao &#123; // 根据IP来查找记录 List&lt;BlackList&gt; findByIp(String ip); // 添加记录 int addBlackList(@Param(\"blackList\") BlackList blackList);&#125;实现 HandlerInterceptor 接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class URLInterceptor implements HandlerInterceptor &#123; @Autowired BlackListDao blackListDao; private Map&lt;String, Integer&gt; redisTemplate = new HashMap&lt;String, Integer&gt;(); private static final Logger logger = LoggerFactory.getLogger(URLInterceptor.class); //在请求处理之前进行调用（Controller方法调用之前） @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; return true; &#125; //请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; String ip = IPAddressUtil.getClientIpAddress(httpServletRequest); List&lt;BlackList&gt; blackLists = blackListDao.findByIp(ip); if (blackLists == null || blackLists.size() == 0)&#123; urlHandle(httpServletRequest, 5000, 10); &#125; else &#123; //强制控制跳转 modelAndView.setViewName(\"/errorpage/error.html\"); &#125; &#125; //在整个请求结束之后被调用 @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125; public void urlHandle(HttpServletRequest request, long limitTime,int limitCount) throws RequestLimitException &#123; /** * 省略业务逻辑部分，参考\"准备\"步骤 */ if (count &gt; limitCount)&#123; //符合锁定条件 Calendar calendar = Calendar.getInstance(); Date iptime=calendar.getTime(); BlackList blackList = new BlackList(ip, iptime); blackListDao.addBlackList(blackList); throw new RequestLimitException(); &#125; &#125;&#125;WebMvcConfigurerAdapter类配置 spring mvc的拦截器 WebMvcConfigurerAdapter。1234567891011121314151617@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter &#123; @Bean //把我们的拦截器注入为bean public HandlerInterceptor getMyInterceptor()&#123; return new URLInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 多个拦截器组成一个拦截器链 // addPathPatterns 用于添加拦截规则, 这里假设拦截 /url 后面的全部链接 // excludePathPatterns 用户排除拦截 registry.addInterceptor(getMyInterceptor()).addPathPatterns(\"/url/**\"); super.addInterceptors(registry); &#125;&#125;Controller类12345@RequestMapping(\"/url/test\")@ResponseBodypublic String URLtest() &#123; return \"success\";&#125;项目参考地址项目参考地址 : https://github.com/FunriLy/springboot-study/tree/master/%E6%A1%88%E4%BE%8B8","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.liurenjie.top/tags/springboot/"}]},{"title":"SpringBoot 实现控制器 IP 访问次数限制","slug":"java2018-03-27-1","date":"2018-03-27T13:41:49.000Z","updated":"2018-06-01T03:59:45.171Z","comments":true,"path":"posts/19a6144d.html","link":"","permalink":"http://blog.liurenjie.top/posts/19a6144d.html","excerpt":"今天给大家介绍一下 SpringBoot 中如何自定义注解实现控制器访问次数限制。在 Web 中最经常发生的就是利用恶性 URL 访问刷爆服务器之类的攻击，今天我就给大家介绍一下如何利用自定义注解实现这类攻击的防御操作。其实这类问题一般的解决思路就是：在控制器中加入自定义注解实现访问次数限制的功能。具体的实现过程看下面的例子：","text":"今天给大家介绍一下 SpringBoot 中如何自定义注解实现控制器访问次数限制。在 Web 中最经常发生的就是利用恶性 URL 访问刷爆服务器之类的攻击，今天我就给大家介绍一下如何利用自定义注解实现这类攻击的防御操作。其实这类问题一般的解决思路就是：在控制器中加入自定义注解实现访问次数限制的功能。具体的实现过程看下面的例子：步骤一：先定义一个注解类，下面看代码事例：12345678910111213141516171819202122package example.controller.limit; import org.springframework.core.Ordered; import org.springframework.core.annotation.Order; import java.lang.annotation.*; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Documented //最高优先级 @Order(Ordered.HIGHEST_PRECEDENCE) public @interface RequestLimit &#123; /** * * 允许访问的次数，默认值MAX_VALUE */ int count() default Integer.MAX_VALUE; /** * * 时间段，单位为毫秒，默认值一分钟 */ long time() default 60000; &#125;步骤二：定义一个异常类，用来处理 URL 攻击时产生的异常问题，下面看代码事例：12345678910111213package example.controller.exception; public class RequestLimitException extends Exception &#123; private static final long serialVersionUID = 1364225358754654702L; public RequestLimitException() &#123; super(\"HTTP请求超出设定的限制\"); &#125; public RequestLimitException(String message) &#123; super(message); &#125; &#125;步骤三：定义一个注解的具体实现类，下面看代码事例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 package example.controller.limit; import example.controller.exception.RequestLimitException; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.Map; import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.TimeUnit; @Aspect @Component public class RequestLimitContract &#123; private static final Logger logger = LoggerFactory.getLogger(\"RequestLimitLogger\"); private Map redisTemplate=new HashMap(); @Before(\"within(@org.springframework.stereotype.Controller *) &amp;&amp; @annotation(limit)\") public void requestLimit(final JoinPoint joinPoint, RequestLimit limit) throws RequestLimitException &#123; try &#123; Object[] args = joinPoint.getArgs(); HttpServletRequest request = null; for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof HttpServletRequest) &#123; request = (HttpServletRequest) args[i]; break; &#125; &#125; if (request == null) &#123; throw new RequestLimitException(\"方法中缺失HttpServletRequest参数\"); &#125; String ip = request.getLocalAddr(); String url = request.getRequestURL().toString(); String key = \"reqlimit\".concat(url).concat(ip); if(redisTemplate.get(key)==null || redisTemplate.get(key)==0)&#123; redisTemplate.put(key,1); &#125;else &#123; redisTemplate.put(key,redisTemplate.get(key)+1); &#125; int count = redisTemplate.get(key); if (count &gt; 0) &#123; Timer timer= new Timer(); TimerTask task = new TimerTask()&#123; //创建一个新的计时器任务。 @Override public void run() &#123; redisTemplate.remove(key); &#125; &#125;; timer.schedule(task, limit.time()); //安排在指定延迟后执行指定的任务。task : 所要安排的任务。: 执行任务前的延迟时间，单位是毫秒。 &#125; if (count &gt; limit.count()) &#123; //logger.info(\"用户IP[\" + ip + \"]访问地址[\" + url + \"]超过了限定的次数[\" + limit.count() + \"]\"); throw new RequestLimitException(); &#125; &#125; catch (RequestLimitException e) &#123; throw e; &#125; catch (Exception e) &#123; logger.error(\"发生异常: \", e); &#125; &#125; &#125;步骤四：实现一个控制类，并添加使用注解功能。下面看代码事例：1234567891011121314151617package example.controller; import example.controller.limit.RequestLimit; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletRequest; @Controller public class URLController &#123; //其中count指的是规定时间内的访问次数，time指的就是规定时间，单位为毫秒。 @RequestLimit(count=10,time=5000) @RequestMapping(\"/urltest\") @ResponseBody public String test(HttpServletRequest request, ModelMap modelMap) &#123; return \"aaa\"; &#125; &#125;这样就实现了在控制器这个层次上面的 url 拦截了。不过这里有个问题，就是如果想在每一个 URL 页面上面都进行这样的拦截，这种方法明显是不够的。因为我们不可能在每个控制器上面都加上 url 拦截的注解，所以这种方法只适合在某些特定的 URL 拦截上面使用它们(例如:短信发送验证码或者是注册这些)","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.liurenjie.top/tags/springboot/"}]},{"title":"js上传图片","slug":"javascript2018-03-23-1","date":"2018-03-23T11:05:49.000Z","updated":"2018-06-01T03:59:45.185Z","comments":true,"path":"posts/5e7994fa.html","link":"","permalink":"http://blog.liurenjie.top/posts/5e7994fa.html","excerpt":"效果图","text":"效果图index.html12345678910111213141516171819&lt;body&gt;&lt;div class=\"Complaint\" &gt;&lt;textarea placeholder=\"请输入内容\" maxlength=\"200\" class=\"comments\" rows=\"6\" id=\"content\" name=\"content\" cols=\"27\" &gt;&lt;/textarea&gt;&lt;/div&gt;&lt;div class=\"Complaint\" style=\"border-top:0\"&gt;请上传图片&lt;span id=\"imgCount\" class=\"imgCount\"&gt;0张&lt;/span&gt; &lt;input id=\"fileBtn\" type=\"file\" name=\"file\" accept=\"image/*\" multiple/&gt; &lt;div id=\"all\" &gt; &lt;span id=\"imgs\"&gt;&lt;/span&gt; &lt;a href=\"javascript:;\" onclick=\"$('#fileBtn').click()\" id=\"imgBtn\"&gt; &lt;img src=\"/s/images/add.png\" class=\"add\"&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div class=\"Btn\"&gt;&lt;a href=\"JavaScript:;\" id=\"submitBtn\"&gt;提交&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131 var count = 4; //允许上传4张图片 var index = 0;//img索引 var panel = 1; $(function()&#123; //图片预览 $('#imgs').on('click','img',function()&#123; var $img = $(this)[0]; var height = $(window).height()-100; // var center = height / 2 - height / 4; // 居中 var dialog = '&lt;div&gt;&lt;img width=\"280px\" src=\"'+$img.src+'\" alt=\"\" style=\"max-height:'+height+'px;\" /&gt;&lt;/div&gt;'; layer.open(&#123; title:'预览', content:dialog, skin:'', btn:['删除','关闭'],// offset: center+'px', maxHeight : height+'px', btn1:function()&#123; // 删除图片 UPLOAD_IMG_DEL($img); &#125; &#125;) &#125;) //上传文件 var $c = $('#fileBtn'), $d = $('#imgs'); var layerLoding ; $c.fileupload(&#123; url : \"url\", autoUpload : true, acceptFileTypes : /(\\.|\\/)(gif|jpe?g|png)$/i, maxNumberOfFiles : 1, maxFileSize : 2097152,// formData:&#123;size:size&#125;, add: function (e, data) &#123;//上传之前的处理11 layerLoding = layer.load(1, &#123; shade: [0.6,'black'] //0.1透明度的白色背景 &#125;); //------------- var file = $c[0].files[0]; var acceptFileTypes = /^image\\/(gif|jpe?g|png)$/i; //图片格式正则// 在执行之前 var imgCount = $d.children('img').size(); if(!acceptFileTypes.test(file['type']))&#123; layer.msg('图片类型必须是.gif，.jpeg，.png，.jpg中的一种!', &#123; icon : 2, time : 2000 &#125;); return false; &#125; if(imgCount &gt; 3 || count &lt; 1) &#123; layer.msg(\"最多只能上传4张图片\",&#123;icon:2,time:2000&#125;); return false; &#125; else&#123; count = count - 1; //剩余可上传数量 // 上传 data.submit(); &#125; //*------------- &#125;, progressall: function (e, data) &#123; var progress = parseInt(data.loaded / data.total * 100, 10); console.log(progress+\"%\"); if(progress == 100) layer.close(layerLoding); &#125;, done : function(e, data) &#123; if(data.result.errorInfo.errorCode)&#123; //执行完之后11 index = index + 1; //增长索引 var imgHtml = '&lt;img src=\"'+data.result.respInfo.path+'\" alt=\"\" id=\"img'+index+'\" width=\"70px\" height=\"70px\" /&gt;' ; $d.append(imgHtml); //最多添加4张 var imgCount = $d.children('img').size(); var $imgCount = $('#imgCount'); $imgCount.text(imgCount+'张'); if(imgCount == 4)&#123; $('#imgBtn').hide(); &#125; // $('#img'+index+'').attr(\"src\",data.result.respInfo.path); &#125; &#125; &#125;); /* 删除上传图片 */ function UPLOAD_IMG_DEL($img) &#123; var param = &#123; fileUrl : $img.src, filePath : 'Complaint' &#125;; $.ajax(&#123; url : \"url\", // 跳转到 action data : JSON.stringify(param), contentType : \"application/json;charset=UTF-8\", type : 'post', cache : false, dataType : 'json', success : function(data) &#123; if(data.errorInfo.errorCode)&#123; $img.remove(); count = count + 1; var imgCount = $('#imgs').children('img').size(); if(imgCount &lt; 4 &amp;&amp; 0 &lt; count)&#123; $('#imgBtn').show(); &#125; var $imgCount = $('#imgCount'); $imgCount.text(imgCount+'张'); layer.msg('删除成功',&#123;icon:1,time:2000&#125;); &#125;else&#123; layer.msg(data.errorInfo.errorMessage,&#123;icon:2,time:2000&#125;); &#125; &#125;,error : function()&#123; layer.msg('删除失败'); &#125; &#125;); &#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"}]},{"title":"高德地图搜索点击反馈","slug":"javascript2018-03-20-1","date":"2018-03-20T20:33:33.000Z","updated":"2018-06-01T03:59:45.182Z","comments":true,"path":"posts/f1981fb1.html","link":"","permalink":"http://blog.liurenjie.top/posts/f1981fb1.html","excerpt":"页面加载完成/提示框选中/点击地图根据经纬度 获取并设置地址直接上代码","text":"页面加载完成/提示框选中/点击地图根据经纬度 获取并设置地址直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta name=\"renderer\" content=\"webkit|ie-comp|ie-stand\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt;&lt;title&gt;小区显示地图&lt;/title&gt;&lt;%@ include file=\"/WEB-INF/jsp/common/public.jsp\"%&gt;&lt;%-- &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"$&#123;s&#125;/css/map.css\" /&gt; --%&gt;&lt;meta name=\"keywords\" content=\"H-ui.admin v3.0,H-ui网站后台模版,后台模版下载,后台管理系统模版,HTML后台模版下载\"&gt;&lt;meta name=\"description\" content=\"H-ui.admin v3.0，是一款由国人开发的轻量级扁平化网站后台模板，完全免费开源的网站后台管理系统模版，适合中小型CMS后台系统。\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"$&#123;s&#125;/css/AMap.css\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;div id=\"myPageTop\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;label&gt;按关键字搜索：&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=\"text\" placeholder=\"请输入关键字进行搜索\" value='$&#123;community.communityName &#125;' id=\"tipinput\" class=\"input-text\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;label&gt;左击获取地址信息：&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;!-- &lt;input type=\"text\" id=\"input\" disabled=\"disabled\" /&gt; --&gt; &lt;span id=\"addr\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"$&#123;s&#125;/js/AMap/addToolbar.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://webapi.amap.com/demos/js/liteToolbar.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://webapi.amap.com/maps?v=1.4.2&amp;key=key\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;var x ='$&#123;empty x?community.addrLatitude : x &#125;',y='$&#123;empty y ?community.addrLongitude :y &#125;';var cName = '$&#123;cName&#125;';var map = new AMap.Map(\"container\", &#123; resizeEnable: true, zoom: 15&#125;);AMap.plugin(['AMap.Autocomplete','AMap.Geocoder'],function()&#123; if('0E-7' != x &amp;&amp; '0E-7' != y) &#123; map.setCenter([y,x]); &#125; else&#123; map.setCity(cName); &#125; //为地图注册click事件获取鼠标点击出的经纬度坐标 var clickEventListener = map.on('click', function(e) &#123; marker.setPosition(e.lnglat); loadAddr(e.lnglat); // 经纬度// document.getElementById(\"lnglat\").value = e.lnglat.getLng() + ',' + e.lnglat.getLat() &#125;); var completeEventListener = map.on('complete', function() &#123; if('0E-7' != x &amp;&amp; '0E-7' != y) &#123; loadAddr(map.vh.center); &#125; &#125;); // 根据经纬度获取地址 function loadAddr(location)&#123; console.log(location); geocoder.getAddress(location,function(status,result)&#123; if(status=='complete')&#123; document.getElementById('addr').innerHTML = result.regeocode.formattedAddress &#125; &#125;) parent.y = location.getLng(); parent.x = location.getLat() parent.document.getElementById(\"position\").innerHTML=parent.x+','+parent.y+'(已设置)'; console.log(parent.document.getElementById(\"position\").innerHTML); &#125; // 地图标点 var marker = new AMap.Marker(&#123; map:map, bubble:true &#125;) //地理编码与逆地理编码服务，提供地址与坐标间的相互转换 var geocoder = new AMap.Geocoder(&#123; city: '010'//城市，默认：“全国” &#125;); var auto = new AMap.Autocomplete(&#123; input: \"tipinput\", city: cName &#125;); AMap.event.addListener(auto, \"select\", select);//注册监听，当选中某条记录时会触发 function select(e) &#123; if (e.poi &amp;&amp; e.poi.location) &#123; map.setZoom(15); map.setCenter(e.poi.location); marker.setPosition(e.poi.location); loadAddr(e.poi.location); &#125; &#125;&#125;);&lt;/script&gt; &lt;!--/请在上方写此页面业务相关的脚本--&gt;&lt;/body&gt;&lt;/html&gt;高德地图api","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"},{"name":"高德地图","slug":"高德地图","permalink":"http://blog.liurenjie.top/tags/高德地图/"}]},{"title":"lambda实体属性去重，对实体的某个属性进行去重","slug":"java2018-03-15-1","date":"2018-03-15T11:20:43.000Z","updated":"2018-06-01T03:59:45.174Z","comments":true,"path":"posts/9ccc251b.html","link":"","permalink":"http://blog.liurenjie.top/posts/9ccc251b.html","excerpt":"下面我将介绍一下如何为一个List&lt;People&gt; 这样的List里面的某个属性进行去重。顺便介绍一下两个实体之间如何用lambda进行复制OK，我们先来写一个Person实体","text":"下面我将介绍一下如何为一个List&lt;People&gt; 这样的List里面的某个属性进行去重。顺便介绍一下两个实体之间如何用lambda进行复制OK，我们先来写一个Person实体123456789101112131415161718192021222324package com.dzy.test.lambda;/** * Created by itar */public class Person &#123; private int age; private String name; private String country; private String address; private String phone;//getter().. setter()... @Override public String toString() &#123; return \"Person&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + \", country='\" + country + '\\'' + \", address='\" + address + '\\'' + \", phone='\" + phone + '\\'' + '&#125;'; &#125;&#125;然后写一个会被复制的People实体，其实这种情况很常见，一般就是从数据库种拿到的entity然后复制到dto中1234567891011121314151617181920212223package com.dzy.test.lambda;/** * Created by itar */public class People &#123; private int age; private String name; private String country; private String address; private String phone; //getter().. setter()... @Override public String toString() &#123; return \"People&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + \", country='\" + country + '\\'' + \", address='\" + address + '\\'' + \", phone='\" + phone + '\\'' + '&#125;'; &#125;&#125;主要的测试类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.dzy.test.lambda;import org.junit.Test;import org.springframework.beans.BeanUtils;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.function.Function;import java.util.function.Predicate;import java.util.stream.Collectors;/** * Created by itar */public class TestPeopleLambda &#123; private static List&lt;Person&gt; personList=new ArrayList&lt;&gt;(); static &#123; for (int i = 1; i &lt;= 20; i++) &#123; Person person=new Person(); person.setAge(i); person.setName(\"xiaoming\"+i); //待会儿筛选属性用到 if (i%10==0)&#123;person.setAddress(\"shanghai10村\");&#125;else&#123; person.setAddress(\"shanghai\"+i+\"村\"); &#125; person.setCountry(\"中国\"+i+\"区\"); personList.add(person); &#125; &#125; @Test public void testLambda()&#123; //下面我要将personList转化为peoplelist里面去，少一个或者多一个属性，看下我怎么做 List&lt;People&gt; peopleList = personList.stream().map(person -&gt; &#123; People people = new People(); BeanUtils.copyProperties(person, people); return people; //下面我做个工作，将shanghai 10村的人合并到一起，也就是说最终会输出17个人people，看看 &#125;).filter(distinctByKey(People::getAddress)).collect(Collectors.toList()); //打印出来的实体只有19个，说明我们筛选成功了，而且成功转成了people实体了 peopleList.forEach(System.out::println); &#125;1234567891011/** * 定义一个过滤器进行去重 * 不涉及到共享变量，没有线程安全问题 * 为什么是这样写的，因为上面的filter是需要一个Predicate返回的参数的 * 用concurrentHashMap里面的putIfAbsent进行排重 */ public static&lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, Object&gt; keyExtractor) &#123; Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); return object -&gt; seen.putIfAbsent(keyExtractor.apply(object), Boolean.TRUE) == null; &#125; &#125;到这里，我们的去重工作就完成了，主要起作用的是distinctByKey 这个方法的使用和编写，本例中仅仅作用于address，还可以定制一些其他的，可以继续filter，添加第二个去重的要求。over!方法22018年添加方法2123List&lt;Person&gt; distinctList = personList.stream().collect( Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getName()))), ArrayList::new));123主要是利用了collectingAndThen 这个方法，第二种方法比较简便","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://blog.liurenjie.top/tags/lambda/"},{"name":"java8","slug":"java8","permalink":"http://blog.liurenjie.top/tags/java8/"}]},{"title":"MongoDB安装及配置，解决只能通过127.0.0.1访问的问题","slug":"mongodb2018-03-14-1","date":"2018-03-14T15:44:41.000Z","updated":"2018-06-01T03:59:45.189Z","comments":true,"path":"posts/c268d8f6.html","link":"","permalink":"http://blog.liurenjie.top/posts/c268d8f6.html","excerpt":"mongodb安装教程创建文件夹12mkdir D:\\Program Files\\MongoDB\\Server\\3.6\\data\\dbmkdir D:\\Program Files\\MongoDB\\Server\\3.6\\data\\log12","text":"mongodb安装教程创建文件夹12mkdir D:\\Program Files\\MongoDB\\Server\\3.6\\data\\dbmkdir D:\\Program Files\\MongoDB\\Server\\3.6\\data\\log12mongod.cfg12345678systemLog: destination: file path: D:\\Program Files\\MongoDB\\Server\\3.6\\data\\log\\mongod.logstorage: dbPath: D:\\Program Files\\MongoDB\\Server\\3.6\\data\\dbnet: port: 27017 bindIp: 0.0.0.0 //绑定ip地址12345678安装MongoDB服务12345678mongod.exe --config \"D:\\Program Files\\MongoDB\\Server\\3.6\\mongod.cfg\" --install1#启动服务net start MongoDB# 暂停服务net stop MongoDB#移除服务mongod.exe --remove菜鸟教程","categories":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.liurenjie.top/categories/mongodb/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.liurenjie.top/tags/mongodb/"}]},{"title":"远程连接mysql 授权","slug":"mysql2018-03-07-2","date":"2018-03-07T15:07:39.000Z","updated":"2018-06-01T03:59:45.198Z","comments":true,"path":"posts/eed65abf.html","link":"","permalink":"http://blog.liurenjie.top/posts/eed65abf.html","excerpt":"报错:1130-host … is not allowed to connect to this MySql server解决方法：1. 改表法。可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 &quot;mysql&quot; 数据库里的 &quot;user&quot; 表里的 &quot;host&quot; 项，从&quot;localhost&quot;改称&quot;%&quot;123mysql -u root -pvmwaremysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user;","text":"报错:1130-host … is not allowed to connect to this MySql server解决方法：1. 改表法。可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 &quot;mysql&quot; 数据库里的 &quot;user&quot; 表里的 &quot;host&quot; 项，从&quot;localhost&quot;改称&quot;%&quot;123mysql -u root -pvmwaremysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user;2. 授权法。例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。GRANT ALL PRIVILEGES ON *.* TO &#39;myuser&#39;@&#39;%&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION;FLUSH PRIVILEGES;如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器，并使用mypassword作为密码GRANT ALL PRIVILEGES ON *.* TO &#39;myuser&#39;@&#39;192.168.1.3&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION;FLUSH PRIVILEGES;如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器的dk数据库，并使用mypassword作为密码GRANT ALL PRIVILEGES ON dk.* TO &#39;myuser&#39;@&#39;192.168.1.3&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION;FLUSH PRIVILEGES;我用的第一个方法,刚开始发现不行,在网上查了一下,少执行一个语句 mysql&gt;FLUSH RIVILEGES 使修改生效.就可以了另外一种方法,不过我没有亲自试过的,在csdn.net上找的,可以看一下.在安装mysql的机器上运行：1、d:\\mysql\\bin\\&gt;mysql -h localhost -u root //这样应该可以进入MySQL服务器2、mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; WITH GRANT OPTION //赋予任何主机访问数据的权限3、mysql&gt;FLUSH PRIVILEGES //修改生效4、mysql&gt;EXIT //退出MySQL服务器这样就可以在其它任何的主机上以root身份登录啦！","categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"}]},{"title":"linux/windows mysql修改密码","slug":"mysql2018-03-07-1","date":"2018-03-07T11:00:02.000Z","updated":"2018-06-01T05:14:42.645Z","comments":true,"path":"posts/f96309b2.html","link":"","permalink":"http://blog.liurenjie.top/posts/f96309b2.html","excerpt":"linux解决方案首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。 因为在重新设置MySQL的root密码的期间，MySQL数据库完全出于没有密码保护的状态下，其他的用户也可以任意地登录和修改MySQL的信息。可以采用将MySQL对外的端口封闭，并且停止Apache以及所有的用户进程的方法实现服务器的准安全 状态。最安全的状态是到服务器的Console上面操作，并且拔掉网线。","text":"linux解决方案首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。 因为在重新设置MySQL的root密码的期间，MySQL数据库完全出于没有密码保护的状态下，其他的用户也可以任意地登录和修改MySQL的信息。可以采用将MySQL对外的端口封闭，并且停止Apache以及所有的用户进程的方法实现服务器的准安全 状态。最安全的状态是到服务器的Console上面操作，并且拔掉网线。修改MySQL的登录设置：vi /etc/my.cnf在[mysqld]的段中加上一句：skip-grant-tables例如：1234[mysqld] datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock skip-grant-tables 1234保存并且退出vi。重新启动mysqld123/etc/init.d/mysqld restart Stopping MySQL: [ OK ] Starting MySQL: [ OK ] 123登录并修改MySQL的root密码123456789101112131415 /usr/bin/mysql Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 3 to server version: 3.23.56 Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the buffer. mysql&gt; USE mysql ; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; UPDATE user SET Password = password ( &apos;new-password&apos; ) WHERE User = &apos;root&apos; ; Query OK, 0 rows affected (0.00 sec) Rows matched: 2 Changed: 0 Warnings: 0 mysql&gt; flush privileges ; Query OK, 0 rows affected (0.01 sec) mysql&gt; quit Bye 123456789101112131415将MySQL的登录设置修改回来vi /etc/my.cnf 1将刚才在[mysqld]的段中加上的skip-grant-tables删除保存并且退出vi。重新启动mysqld/etc/init.d/mysqld restartStopping MySQL: [ OK ]Starting MySQL: [ OK ]Work for fun,Live for love!12345Windows解决方案方法一：在DOS窗口下输入net stop mysql5 或 net stop mysql开一个DOS窗口，这个需要切换到mysql的bin目录。一般在bin目录里面创建一个批处理1.bat,内容是cmd.exe运行一下即可就切换到当前目录，然后输入1mysqld-nt --skip-grant-tables; 1或1mysqld --skip-grant-tables;1不要关闭窗口再开一个DOS窗口，mysql -u root输入：复制代码 代码如下:1234use mysql update user set password=password(&quot;new_pass&quot;) where user=&quot;root&quot;; flush privileges; exit 1234使用任务管理器，找到mysqld-nt的进程，结束进程或下面的步骤停止MYSQL服务，CMD打开DOS窗口，输入 net stop mysql在CMD命令行窗口，进入MYSQL安装目录 比如E:\\Program Files\\MySQL\\MySQL Server 5.0\\bin示范命令:输入 e:回车,输入cd &quot;E:\\Program Files\\MySQL\\MySQL Server 5.0\\bin&quot;注意双引号也要输入,这样就可以进入Mysql安装目录了.进入mysql安全模式，即当mysql起来后，不用输入密码就能进入数据库。命令为： mysqld-nt –skip-grant-tables重新打开一个CMD命令行窗口，输入mysql -uroot -p，使用空密码的方式登录MySQL（不用输入密码，直接按回车）输入以下命令开始修改root用户的密码（注意：命令中mysql.user中间有个“点”）1mysql&gt; update mysql.user set password=PASSWORD(&apos;新密码&apos;) where User=&apos;root&apos;;刷新权限表1mysql&gt; flush privileges; 1退出1mysql&gt; quit 1这样MYSQL超级管理员账号 ROOT已经重新设置好了，接下来 在任务管理器里结束掉 mysql-nt.exe 这个进程，重新启动MYSQL即可！（也可以直接重新启动服务器）MYSQL重新启动后，就可以用新设置的ROOT密码登陆MYSQL了！方法二：首先在 MySQL的安装目录下 新建一个pwdhf.txt, 输入文本：SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;*****&#39;);红色部份为 需要设置的新密码用windows服务管理工具或任务管理器来停止MySQL服务 (任务管理器K掉 mysqld-nt 进程)Dos命令提示符到 MySQL安装目录下的bin目录 如我的是 D:\\Program Files\\MySQL\\MySQL Server 5.1\\bin然后运行： mysqld-nt --init-file=../pwdhf.txt执行完毕 停止MySQL数据库服务 (任务管理器K掉 mysqld-nt 进程)，然后再重新以正常模式启动MYSQL 即可","categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/categories/mysql/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://blog.liurenjie.top/tags/windows/"},{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/tags/linux/"}]},{"title":"Redis配置参数的热修改 设置有效时间","slug":"redis2017-08-29-1","date":"2017-08-29T14:26:56.000Z","updated":"2018-06-01T03:59:45.199Z","comments":true,"path":"posts/7f4c8f65.html","link":"","permalink":"http://blog.liurenjie.top/posts/7f4c8f65.html","excerpt":"Redis使用config命令，可以对配置项参数热修改，不必重启。redis最好不要重启，重启一次会引发如下问题：1、如果数据很多（例如几个G），读起来很慢；2、重启风险很大，Redis有内存陷阱3、重启会引发读快照，读AOF文件","text":"Redis使用config命令，可以对配置项参数热修改，不必重启。redis最好不要重启，重启一次会引发如下问题：1、如果数据很多（例如几个G），读起来很慢；2、重启风险很大，Redis有内存陷阱3、重启会引发读快照，读AOF文件使用config get * 获得所有的配置项的keyconfig set timeout 250改变key的valueconfig get * 查看flushdb 清空刷新redis缓存","categories":[{"name":"redis","slug":"redis","permalink":"http://blog.liurenjie.top/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.liurenjie.top/tags/redis/"}]},{"title":"mysql数据关联查询及显示问题,一对多查询","slug":"mysql2017-08-17-1","date":"2017-08-17T14:55:40.000Z","updated":"2018-06-01T03:59:45.195Z","comments":true,"path":"posts/646fd565.html","link":"","permalink":"http://blog.liurenjie.top/posts/646fd565.html","excerpt":"表aaidatitleatext1测试1测试1测试1测试1测试1测试12测试2测试2测试2测试2测试2测试2表b:bidaidbclass11red21green32red41white","text":"表aaidatitleatext1测试1测试1测试1测试1测试1测试12测试2测试2测试2测试2测试2测试2表b:bidaidbclass11red21green32red41white查询语句：SELECT a.*,b.bclass FROM aleft JOIN B ON a.aid = b.aid WHERE a.aid=1结果：| aid | atitle | atext | bclass || —- | —— | ————————- | —— || 1 | 测试1 | 测试1测试1测试1测试1测试1 | red || 1 | 测试1 | 测试1测试1测试1测试1测试1 | green || 1 | 测试1 | 测试1测试1测试1测试1测试1 | white |这样在显示bclass数据时，atitle及atext数据就要重复读取。通过下面的语句查询，达到如下一种效果：select a.aid,a.atitle ,a.atext,group_concat(b.bclass) FROM aleft JOIN B ON a.aid = b.aid WHERE a.aid=1 group by a.aid| aid | atitle | atext | bclass || —- | —— | ————————- | ————— || 1 | 测试1 | 测试1测试1测试1测试1测试1 | red,green,white |GROUP_CONCAT(b.bclass SEPARATOR ‘|’)可改变分隔符号。同理，可进行三表查询123456SELECT A.*,group_concat(C.name) FROM A LEFT JOIN B ON A.id = B.id LEFT JOIN C ON B.class_id = C.class_id GROUP BY a.idgroup_concat(conv(oct(B.id),8,10 )) 如内容为string 直接group_concat(string)，如是整数的，须进行转换。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"}]},{"title":"阿里云上部署kafka--遇到的坑","slug":"java2017-08-04-1","date":"2017-08-04T17:36:50.000Z","updated":"2018-06-01T03:59:45.168Z","comments":true,"path":"posts/cf59dde7.html","link":"","permalink":"http://blog.liurenjie.top/posts/cf59dde7.html","excerpt":"kafka文档kafka下载包kafka-manager 后台管理系统阿里云防火墙关闭，并且配置规则。不然会导致访问不到服务。问题一：Caused by: java.net.UnknownHostException: iZuf68tztea6l5ccdz7wemZ: iZuf68tztea6l5ccdz7wemZ: Name or service not known","text":"kafka文档kafka下载包kafka-manager 后台管理系统阿里云防火墙关闭，并且配置规则。不然会导致访问不到服务。问题一：Caused by: java.net.UnknownHostException: iZuf68tztea6l5ccdz7wemZ: iZuf68tztea6l5ccdz7wemZ: Name or service not known12vi /etc/hosts127.0.0.1 iZuf68tztea6l5ccdz7wemZ12iZuf68tztea6l5ccdz7wemZ 自己的主机名问题二：ERROR Error when sending message to topic test with key: null, value: 3 bytes with error: (org.apache.kafka.clients.producer.internals.ErrorLoggingCallback)org.apache.kafka.common.errors.TimeoutException: Batch containing 2 record(s) expired due to timeoutwhile requesting metadata from brokers for test-012345# The id of the broker. This must be set to a unique integer for each broker.broker.id=0port=9092host.name=阿里云内网地址advertised.host.name=阿里云外网映射地址","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"kafka","slug":"kafka","permalink":"http://blog.liurenjie.top/tags/kafka/"}]},{"title":"eclipse安装Gradle插件","slug":"java2017-07-31-1","date":"2017-07-31T20:01:44.000Z","updated":"2018-06-01T03:59:45.165Z","comments":true,"path":"posts/9305102a.html","link":"","permalink":"http://blog.liurenjie.top/posts/9305102a.html","excerpt":"1、项目地址https://github.com/eclipse/buildship可以直接下载项目然后eclipse本地安装，也可以按下面的方法2、eclipse在线安装(1)在线安装地址指南：https://github.com/eclipse/buildship/blob/master/docs/user/Installation.md不同的eclipse版本对应的插件版本链接如下：","text":"1、项目地址https://github.com/eclipse/buildship可以直接下载项目然后eclipse本地安装，也可以按下面的方法2、eclipse在线安装(1)在线安装地址指南：https://github.com/eclipse/buildship/blob/master/docs/user/Installation.md不同的eclipse版本对应的插件版本链接如下：Eclipse VersionTypeUpdate SiteNeon (4.6)releasehttp://download.eclipse.org/buildship/updates/e46/releases/1.0milestonehttp://download.eclipse.org/buildship/updates/e46/milestones/1.0snapshothttp://download.eclipse.org/buildship/updates/e46/snapshots/1.0Mars (4.5)releasehttp://download.eclipse.org/buildship/updates/e45/releases/1.0milestonehttp://download.eclipse.org/buildship/updates/e45/milestones/1.0snapshothttp://download.eclipse.org/buildship/updates/e45/snapshots/1.0Luna (4.4)releasehttp://download.eclipse.org/buildship/updates/e44/releases/1.0milestonehttp://download.eclipse.org/buildship/updates/e44/milestones/1.0snapshothttp://download.eclipse.org/buildship/updates/e44/snapshots/1.0Kepler (4.3)releasehttp://download.eclipse.org/buildship/updates/e43/releases/1.0milestonehttp://download.eclipse.org/buildship/updates/e43/milestones/1.0snapshothttp://download.eclipse.org/buildship/updates/e43/snapshots/1.0Juno (4.2)releasehttp://download.eclipse.org/buildship/updates/e42/releases/1.0milestonehttp://download.eclipse.org/buildship/updates/e42/milestones/1.0snapshothttp://download.eclipse.org/buildship/updates/e42/snapshots/1.0Indigo (3.7)releasehttp://download.eclipse.org/buildship/updates/e37/releases/1.0milestonehttp://download.eclipse.org/buildship/updates/e37/milestones/1.0snapshothttp://download.eclipse.org/buildship/updates/e37/snapshots/1.0Helios (3.6)releasehttp://download.eclipse.org/buildship/updates/e36/releases/1.0milestonehttp://download.eclipse.org/buildship/updates/e36/milestones/1.0snapshothttp://download.eclipse.org/buildship/updates/e36/snapshots/1.0找到对应的eclipse版本拷贝链接。(2)打开eclipse，依次按以下步骤操作 window 安装gradle前提条件安装jvm，并配置好了java环境变量安装步骤1.下载gradle 2.3版本2.将压缩包解压到某个目录如 e:/gradle添加GRADLE_HOME 地址添加PATH环境变量：%GRADLE_HOME%\\bin;验证是否安装成功cmd中输入 gradle -version12345678Gradle 2.3Build time: 2015-02-16 05:09:33 UTC Build number: none Revision: 586be72bf6e3df1ee7676d1f2a3afd9157341274Groovy: 2.3.9 Ant: Apache Ant(TM) version 1.9.3 compiled on December 23 2013 JVM: 1.7.0_17 (Oracle Corporation 23.7-b01) OS: Windows 7 6.1 amd64","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"gradle","slug":"gradle","permalink":"http://blog.liurenjie.top/tags/gradle/"},{"name":"eclipse","slug":"eclipse","permalink":"http://blog.liurenjie.top/tags/eclipse/"}]},{"title":"Vue项目启动问题","slug":"vue2017-07-28-1","date":"2017-07-28T21:27:18.000Z","updated":"2018-06-01T03:59:45.201Z","comments":true,"path":"posts/13167427.html","link":"","permalink":"http://blog.liurenjie.top/posts/13167427.html","excerpt":"错误日志：12$ npm install npm ERR! code EINTEGRITY npm ERR! sha1-VNjrx5SfGngQkItgAsaEFSbJnVo= integrity checksum failed when using sha1: wanted sha1-VNjrx5SfGngQkItgAsaEFSbJnVo= but got sha1-uIxYZhgBXoyNhah6nWDV HgUP1Bk=. (65013 bytes)","text":"错误日志：12$ npm install npm ERR! code EINTEGRITY npm ERR! sha1-VNjrx5SfGngQkItgAsaEFSbJnVo= integrity checksum failed when using sha1: wanted sha1-VNjrx5SfGngQkItgAsaEFSbJnVo= but got sha1-uIxYZhgBXoyNhah6nWDV HgUP1Bk=. (65013 bytes)解决方案：12345npm set registry https://registry.npmjs.org/rm -rf node_modules/npm cache clean --forcenpm cache verifynpm install","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.liurenjie.top/categories/nodejs/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.liurenjie.top/tags/vue/"},{"name":"nodejs","slug":"nodejs","permalink":"http://blog.liurenjie.top/tags/nodejs/"}]},{"title":"JAVA 验证码生成","slug":"java2017-07-19-1","date":"2017-07-19T16:00:21.000Z","updated":"2018-06-01T03:59:45.203Z","comments":true,"path":"posts/e71a04da.html","link":"","permalink":"http://blog.liurenjie.top/posts/e71a04da.html","excerpt":"最近做了一下验证码的功能，网上找了一篇还不错，引用下：http://blog.csdn.net/ruixue0117/article/details/22829557这篇文章非常好，但是web和jsp里简单的代码那位大神没有补充，我补充下源码下载路径：http://download.csdn.net/detail/u010320675/9539190JAVA代码：","text":"最近做了一下验证码的功能，网上找了一篇还不错，引用下：http://blog.csdn.net/ruixue0117/article/details/22829557这篇文章非常好，但是web和jsp里简单的代码那位大神没有补充，我补充下源码下载路径：http://download.csdn.net/detail/u010320675/9539190JAVA代码：AuthImage类:123456789101112131415161718192021222324252627282930313233import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession;/** * &lt;p&gt;&lt;b&gt;AuthImage Description:&lt;/b&gt; (验证码)&lt;/p&gt; * &lt;b&gt;DATE:&lt;/b&gt; 2016年6月2日 下午3:53:12 */public class AuthImage extends javax.servlet.http.HttpServlet implements javax.servlet.Servlet &#123; static final long serialVersionUID = 1L; public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setHeader(\"Pragma\", \"No-cache\"); response.setHeader(\"Cache-Control\", \"no-cache\"); response.setDateHeader(\"Expires\", 0); response.setContentType(\"image/jpeg\"); //生成随机字串 String verifyCode = VerifyCodeUtils.generateVerifyCode(4); //存入会话session HttpSession session = request.getSession(true); //删除以前的 session.removeAttribute(\"verCode\"); session.setAttribute(\"verCode\", verifyCode.toLowerCase()); //生成图片 int w = 100, h = 30; VerifyCodeUtils.outputImage(w, h, response.getOutputStream(), verifyCode); &#125; &#125;VerifyCodeUtils类，生成图片流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.RenderingHints;import java.awt.geom.AffineTransform;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.Arrays;import java.util.Random;import javax.imageio.ImageIO;/** * &lt;p&gt;&lt;b&gt;VerifyCodeUtils Description:&lt;/b&gt; (验证码生成)&lt;/p&gt; * &lt;b&gt;DATE:&lt;/b&gt; 2016年6月2日 下午3:53:34 */public class VerifyCodeUtils&#123; //使用到Algerian字体，系统里没有的话需要安装字体，字体只显示大写，去掉了1,0,i,o几个容易混淆的字符 public static final String VERIFY_CODES = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\"; private static Random random = new Random(); /** * 使用系统默认字符源生成验证码 * @param verifySize 验证码长度 * @return */ public static String generateVerifyCode(int verifySize)&#123; return generateVerifyCode(verifySize, VERIFY_CODES); &#125; /** * 使用指定源生成验证码 * @param verifySize 验证码长度 * @param sources 验证码字符源 * @return */ public static String generateVerifyCode(int verifySize, String sources)&#123; if(sources == null || sources.length() == 0)&#123; sources = VERIFY_CODES; &#125; int codesLen = sources.length(); Random rand = new Random(System.currentTimeMillis()); StringBuilder verifyCode = new StringBuilder(verifySize); for(int i = 0; i &lt; verifySize; i++)&#123; verifyCode.append(sources.charAt(rand.nextInt(codesLen-1))); &#125; return verifyCode.toString(); &#125; /** * 生成随机验证码文件,并返回验证码值 * @param w * @param h * @param outputFile * @param verifySize * @return * @throws IOException */ public static String outputVerifyImage(int w, int h, File outputFile, int verifySize) throws IOException&#123; String verifyCode = generateVerifyCode(verifySize); outputImage(w, h, outputFile, verifyCode); return verifyCode; &#125; /** * 输出随机验证码图片流,并返回验证码值 * @param w * @param h * @param os * @param verifySize * @return * @throws IOException */ public static String outputVerifyImage(int w, int h, OutputStream os, int verifySize) throws IOException&#123; String verifyCode = generateVerifyCode(verifySize); outputImage(w, h, os, verifyCode); return verifyCode; &#125; /** * 生成指定验证码图像文件 * @param w * @param h * @param outputFile * @param code * @throws IOException */ public static void outputImage(int w, int h, File outputFile, String code) throws IOException&#123; if(outputFile == null)&#123; return; &#125; File dir = outputFile.getParentFile(); if(!dir.exists())&#123; dir.mkdirs(); &#125; try&#123; outputFile.createNewFile(); FileOutputStream fos = new FileOutputStream(outputFile); outputImage(w, h, fos, code); fos.close(); &#125; catch(IOException e)&#123; throw e; &#125; &#125; /** * 输出指定验证码图片流 * @param w * @param h * @param os * @param code * @throws IOException */ public static void outputImage(int w, int h, OutputStream os, String code) throws IOException&#123; int verifySize = code.length(); BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB); Random rand = new Random(); Graphics2D g2 = image.createGraphics(); g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON); Color[] colors = new Color[5]; Color[] colorSpaces = new Color[] &#123; Color.WHITE, Color.CYAN, Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE, Color.PINK, Color.YELLOW &#125;; float[] fractions = new float[colors.length]; for(int i = 0; i &lt; colors.length; i++)&#123; colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)]; fractions[i] = rand.nextFloat(); &#125; Arrays.sort(fractions); g2.setColor(Color.GRAY);// 设置边框色 g2.fillRect(0, 0, w, h); Color c = getRandColor(200, 250); g2.setColor(c);// 设置背景色 g2.fillRect(0, 2, w, h-4); //绘制干扰线 Random random = new Random(); g2.setColor(getRandColor(160, 200));// 设置线条的颜色 for (int i = 0; i &lt; 20; i++) &#123; int x = random.nextInt(w - 1); int y = random.nextInt(h - 1); int xl = random.nextInt(6) + 1; int yl = random.nextInt(12) + 1; g2.drawLine(x, y, x + xl + 40, y + yl + 20); &#125; // 添加噪点 float yawpRate = 0.05f;// 噪声率 int area = (int) (yawpRate * w * h); for (int i = 0; i &lt; area; i++) &#123; int x = random.nextInt(w); int y = random.nextInt(h); int rgb = getRandomIntColor(); image.setRGB(x, y, rgb); &#125; shear(g2, w, h, c);// 使图片扭曲 g2.setColor(getRandColor(100, 160)); int fontSize = h-4; Font font = new Font(\"Algerian\", Font.ITALIC, fontSize); g2.setFont(font); char[] chars = code.toCharArray(); for(int i = 0; i &lt; verifySize; i++)&#123; AffineTransform affine = new AffineTransform(); affine.setToRotation(Math.PI / 4 * rand.nextDouble() * (rand.nextBoolean() ? 1 : -1), (w / verifySize) * i + fontSize/2, h/2); g2.setTransform(affine); g2.drawChars(chars, i, 1, ((w-10) / verifySize) * i + 5, h/2 + fontSize/2 - 10); &#125; g2.dispose(); ImageIO.write(image, \"jpg\", os); &#125; private static Color getRandColor(int fc, int bc) &#123; if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; private static int getRandomIntColor() &#123; int[] rgb = getRandomRgb(); int color = 0; for (int c : rgb) &#123; color = color &lt;&lt; 8; color = color | c; &#125; return color; &#125; private static int[] getRandomRgb() &#123; int[] rgb = new int[3]; for (int i = 0; i &lt; 3; i++) &#123; rgb[i] = random.nextInt(255); &#125; return rgb; &#125; private static void shear(Graphics g, int w1, int h1, Color color) &#123; shearX(g, w1, h1, color); shearY(g, w1, h1, color); &#125; private static void shearX(Graphics g, int w1, int h1, Color color) &#123; int period = random.nextInt(2); boolean borderGap = true; int frames = 1; int phase = random.nextInt(2); for (int i = 0; i &lt; h1; i++) &#123; double d = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (6.2831853071795862D * (double) phase) / (double) frames); g.copyArea(0, i, w1, 1, (int) d, 0); if (borderGap) &#123; g.setColor(color); g.drawLine((int) d, i, 0, i); g.drawLine((int) d + w1, i, w1, i); &#125; &#125; &#125; private static void shearY(Graphics g, int w1, int h1, Color color) &#123; int period = random.nextInt(40) + 10; // 50; boolean borderGap = true; int frames = 20; int phase = 7; for (int i = 0; i &lt; w1; i++) &#123; double d = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (6.2831853071795862D * (double) phase) / (double) frames); g.copyArea(i, 0, 1, h1, 0, (int) d); if (borderGap) &#123; g.setColor(color); g.drawLine(i, (int) d, i, 0); g.drawLine(i, (int) d + h1, i, h1); &#125; &#125; &#125; public static void main(String[] args) throws IOException&#123; File dir = new File(\"F:/verifies\"); int w = 200, h = 80; for(int i = 0; i &lt; 50; i++)&#123; String verifyCode = generateVerifyCode(4); File file = new File(dir, verifyCode + \".jpg\"); outputImage(w, h, file, verifyCode); &#125; &#125;&#125;web.xml写法123456789&lt;!-- 登录验证码 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;AuthImage&lt;/servlet-name&gt; &lt;servlet-class&gt;com.toft.widgets.login.AuthImage&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;AuthImage&lt;/servlet-name&gt; &lt;url-pattern&gt;/authImage&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;JSP 页面写法，有刷新操作1234567891011121314151617&lt;!-- 验证码 --&gt;&lt;tr&gt; &lt;td nowrap width=\"437\"&gt;&lt;/td&gt; &lt;td&gt; &lt;img id=\"img\" src=\"$&#123;ctx&#125;/authImage\" /&gt; &lt;a href='#' onclick=\"javascript:changeImg()\" style=\"color:white;\"&gt;&lt;label style=\"color:white;\"&gt;看不清？&lt;/label&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 触发JS刷新--&gt; &lt;script type=\"text/javascript\"&gt; function changeImg()&#123; var img = document.getElementById(\"img\"); img.src = \"$&#123;ctx&#125;/authImage?date=\" + new Date();; &#125;&lt;/script&gt;如果不想copy直接下载代码，下载路径：http://download.csdn.net/detail/u010320675/9539190","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"验证码","slug":"验证码","permalink":"http://blog.liurenjie.top/tags/验证码/"}]},{"title":"防止频繁刷验证码接口-luosimao","slug":"java2017-07-12-1","date":"2017-07-12T10:52:49.000Z","updated":"2018-06-01T03:59:45.163Z","comments":true,"path":"posts/a27e19f0.html","link":"","permalink":"http://blog.liurenjie.top/posts/a27e19f0.html","excerpt":"在html中很容易可以拿到接口进行恶意访问，然后看到www.luosimao.com提供了免费的人机验证服务。虽然有的做了图形验证码也有可能被破解，了解到点击的图形验证码，小试一下。注册一个luosimao的账号。选择人机验证，并添加新的网站在客户端页面中添加以下相应的dom和脚本， site-key是创建完新网站，直接复制替换即可 // 这是异步的方式，如果使用同步的方式可参考文档用表单的形式提交","text":"在html中很容易可以拿到接口进行恶意访问，然后看到www.luosimao.com提供了免费的人机验证服务。虽然有的做了图形验证码也有可能被破解，了解到点击的图形验证码，小试一下。注册一个luosimao的账号。选择人机验证，并添加新的网站在客户端页面中添加以下相应的dom和脚本， site-key是创建完新网站，直接复制替换即可 // 这是异步的方式，如果使用同步的方式可参考文档用表单的形式提交1234567891011121314151617&lt;div class=\"l-captcha\" data-site-key=\"替换这里\" data-callback=\"getResponse\" data-width=\"250px\"&gt;&lt;/div&gt;&lt;a href=\"javascript:;\" onclick=\"luosimaoRefresh();\" class=\"l-reset\"&gt;&lt;/a&gt;&lt;script&gt;//验证完后成功会回调，并生成一个tokenfunction getResponse(resp)&#123; luosimaoResp = resp; console.log(resp); // resp 即验证成功后获取的值&#125;//重置验证function luosimaoRefresh()&#123; luosimaoResp=\"\"; LUOCAPTCHA.reset();&#125;&lt;/script&gt;服务端 替换 APIKEY1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.ldd.common.luosimao;import java.util.HashMap;import java.util.Map;import org.json.JSONObject;import com.ldd.common.util.HttpUtil;/** * @Description：luosimao 人机验证 * @Author：lrj * @Date：2017年7月11日 上午11:28:36 */public class LuosimaoApi&#123; public static final String APIKEY = \"替换这里\"; public static final String VALIDATE_URL = \"https://captcha.luosimao.com/api/site_verify\"; /** * @Description：人机验证 * @Author：lrj * @Date：2017年7月11日 上午11:53:38 * resp 在客户端中会生成的token * @return */ public static boolean checkAuth(String resp) &#123; Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); params.put(\"api_key\", APIKEY); params.put(\"response\", resp); boolean flag = false; try &#123; String httpResponse = HttpUtil.doPost(VALIDATE_URL, params); JSONObject jsonObj = new JSONObject(httpResponse); int error_code = jsonObj.getInt(\"error\"); String res = jsonObj.getString(\"res\"); if (error_code == 0 &amp;&amp; \"success\".compareTo(res) == 0) &#123; flag = true; System.out.println(\"Send message success.\"); &#125; else &#123; String error_msg = jsonObj.getString(\"msg\"); System.out.println(\"Fetch deposit failed,code is \" + error_code + \",msg is \" + error_msg); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return flag; &#125;&#125;https://luosimao.com/docs/api/56 文档。","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"},{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"验证码","slug":"验证码","permalink":"http://blog.liurenjie.top/tags/验证码/"}]},{"title":"mvn配置settings文件","slug":"maven2017-07-12-1","date":"2017-07-12T10:35:57.000Z","updated":"2018-06-01T03:59:45.192Z","comments":true,"path":"posts/d3cace8d.html","link":"","permalink":"http://blog.liurenjie.top/posts/d3cace8d.html","excerpt":"","text":"设置仓库地址：&lt;localRepository&gt;D:\\xxxx\\repository&lt;/localRepository&gt;配置阿里云仓库：123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;","categories":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/tags/maven/"}]},{"title":"maven构建ojdbc.jar包到本地仓库","slug":"maven2017-05-01-1","date":"2017-05-01T13:54:00.000Z","updated":"2018-06-01T03:59:45.187Z","comments":true,"path":"posts/bb099590.html","link":"","permalink":"http://blog.liurenjie.top/posts/bb099590.html","excerpt":"","text":"首先下载ojdbc14-10.2.0.4.0.jar这个包，并且将jar包的命名方式该成ojdbc-..0.*.0.jar,后面的其实是版本号；然后再本地仓库中创建如下路径： D:\\mavenJava\\repository\\com\\Oracle\\ojdbc14\\10.2.0.4.0，这里我的本地仓库路径为D:\\mavenJava\\repository\\。然后将命名好的jar包放在刚才创建的目录下面，同时将这个jar包放在C盘的根目录下一份。 在cmd中输入如下代码，并运行：mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=C:\\ojdbc14-10.2.0.4.0.jar","categories":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/tags/maven/"}]},{"title":"自动批量删除微博取消关注删除私信脚本","slug":"javascript2017-04-22-1","date":"2017-04-22T16:37:54.000Z","updated":"2018-05-31T10:24:00.861Z","comments":true,"path":"posts/c094b98c.html","link":"","permalink":"http://blog.liurenjie.top/posts/c094b98c.html","excerpt":"chrome示例f12打开开发者工具找到相应的页面在开发者工具中有一栏 console粘贴对应脚本，回车个人娱乐，手动删除太麻烦了。","text":"chrome示例f12打开开发者工具找到相应的页面在开发者工具中有一栏 console粘贴对应脚本，回车个人娱乐，手动删除太麻烦了。自动删除微博 这条脚本来知乎1234567var index = 3;function rm()&#123; document.getElementsByClassName(\"WB_feed WB_feed_v3 WB_feed_v4\")[0].childNodes[index].childNodes[1].childNodes[1].childNodes[1].childNodes[2].childNodes[1].childNodes[1].childNodes[0].click(); document.getElementsByClassName(\"W_layer W_layer_pop \")[0].childNodes[1].childNodes[5].childNodes[1].click(); index++;&#125;self.setInterval(\"rm()\",1000);自动取消关注12345678910function qxgz()&#123; document.getElementsByClassName(\"btn_link S_txt1\")[0].click(); var arrs = document.getElementsByClassName(\"member_li S_bg1 \"); for(var i = 0;i&lt;arrs.length;i++)&#123; arrs[i].click(); &#125; document.getElementsByClassName(\"W_btn_a\")[1].click(); document.getElementsByClassName(\"W_btn_a btn_34px\")[0].click();&#125;self.setInterval(\"qxgz()\",10000);自动仅移除粉丝123456789101112var index =1;function ycfs()&#123; try&#123; document.getElementsByClassName(\"PCD_connectlist\")[0].childNodes[1].childNodes [9].childNodes[1].childNodes[3].childNodes[index].childNodes[1].childNodes[5].childNodes[5].childNodes[1].childNodes[1].childNodes[0].click(); &#125; catch(e)&#123; console.log(e); &#125; document.getElementsByClassName('content layer_mini_opt')[0].childNodes[5].childNodes[1].click(); index ++;&#125;self.setInterval(\"ycfs()\",1000);自动清理私信 以及订阅消息1234567var index =3;function rmMsg()&#123; document.getElementsByClassName('private_body')[0].childNodes[index].childNodes[7].childNodes[1].childNodes[1].childNodes[0].click(); document.getElementsByClassName('W_layer')[1].childNodes[2].childNodes[7].childNodes[1].click(); index++;&#125;self.setInterval(\"rmMsg()\",3000);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"},{"name":"weibo","slug":"weibo","permalink":"http://blog.liurenjie.top/tags/weibo/"}]},{"title":"ubuntu16.04升级17.04","slug":"nginx2017-04-16-1","date":"2017-04-16T10:21:39.000Z","updated":"2018-06-01T01:42:51.448Z","comments":true,"path":"posts/12b4dbc0.html","link":"","permalink":"http://blog.liurenjie.top/posts/12b4dbc0.html","excerpt":"ubuntu16.04 -》ubuntu16.10先升级到这个版本。在升级版本的时候一定要打开设置-软件和更新-开发者选项中：选中 提前释放出的更新每次升级系统都需要去看看并打开以下介绍Ubuntu 16.04升级到Ubuntu 16.10的方法：更新系统：$ sudo apt-get update &amp;&amp; sudo apt-get upgrade安装update-manager-core：$ sudo apt-get install update-manager-core","text":"ubuntu16.04 -》ubuntu16.10先升级到这个版本。在升级版本的时候一定要打开设置-软件和更新-开发者选项中：选中 提前释放出的更新每次升级系统都需要去看看并打开以下介绍Ubuntu 16.04升级到Ubuntu 16.10的方法：更新系统：$ sudo apt-get update &amp;&amp; sudo apt-get upgrade安装update-manager-core：$ sudo apt-get install update-manager-core编辑/etc/update-manager/release-upgrades，把Prompt改为normal;升级：$ sudo do-release-upgrade -d成功升级到了Ubuntu 16.10;然后从16.10-》17.04。如果刚升级玩16.10 可以直接决进行检查 apt-get update如果没有的话，需要去编辑/etc/update-manager/release-upgrades，把Prompt改为normal;sudo update-manager -d 等待更新就好了。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/categories/nginx/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://blog.liurenjie.top/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/tags/nginx/"}]},{"title":"ubuntu下手动编译openjdk7","slug":"java2017-04-09-1","date":"2017-04-09T16:11:06.000Z","updated":"2018-05-31T10:24:00.888Z","comments":true,"path":"posts/46e18e9b.html","link":"","permalink":"http://blog.liurenjie.top/posts/46e18e9b.html","excerpt":"获取源码我是在其他博客找到的，原来的地址抱歉。建议第一种方式：openjdk 7 源代码 http://pan.baidu.com/s/1c2lZ3Tu 密码：2lvn强烈建议初学者，用这个jdk源代码，按照下面的教程配置。其他源代码编译时，可能会出现各种古怪问题下载构建工具","text":"获取源码我是在其他博客找到的，原来的地址抱歉。建议第一种方式：openjdk 7 源代码 http://pan.baidu.com/s/1c2lZ3Tu 密码：2lvn强烈建议初学者，用这个jdk源代码，按照下面的教程配置。其他源代码编译时，可能会出现各种古怪问题下载构建工具1sudo apt-get install build-essential gawk m4 openjdk-8-jdk libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif3 libmotif-div ant请先阅读源码内的README-builds.html进入openjdk 进行配置可以参阅 readme-beuilds.html中的配置。编译start 直接执行文件jdk-build.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/sh #语言选项，这个必须设置，否则编译好后会出现hashtable的npe错 export LANG=C #bootstrap jdk的安装路径，必须设置 export ALT_BOOTDIR=/usr/lib/jvm/jdk1.7.0_80 #允许自动下载依赖 export ALLOW_DOWNLOADS=true #并行编译的线程数，设置为和cpu内核数量一样即可 export HOTSPOT_BUILD_JOBS=4 export ALT_PARALLEL_COMPILE_JOBS=4 #比较本次build出来的映像与之前版本的差异。这对我们来说没有意义 #必须设置为false，否则sanity检查会报缺少先前版本jdk的映像的错误提示 #如果已经设置dev或者dev_only=true，这个不显示设置也行 export SKIP_COMPARE_IMAGES=true #使用预编译头文件，不加这个编译会更慢一些 export USE_PRECOMPILED_HEADER=true #要编译的内容 export BUILD_LANGTOOLS=true #export BUILD_JAXP=false #export BUILD_JAXWS=false #export BUILD_CORBA=false export BUILD_HOTSPOT=true export BUILD_JDK=true #要编译的版本 #export SKIP_DEBUG_BUILD=false #export SKIP_FASTDEBUG_BUILD=true #export DEBUG_NAME=debug #把它设置为false可以避开javaws和浏览器java插件之类的部分build export BUILD_DEPLOY=false #把它设置为false就不会build出安装包，因为安装包里有些奇怪的依赖 #但即便不build出它也已经能得到完整的jdk映像，所以还是别build好了 export BUILD_INSTALL=false #编译结果所存放的路径 export ALT_OUTPUTDIR=/home/liurenjie/openjdk7/build #这两个环境变量必须去掉，不然会出现很诡异的事情 unset JAVA_HOME unset CLASSPATH if [ -x \"build\" ] ;then echo ***********start clean************** make clean else echo ***********start build************** make 2&gt;&amp;1|tee $ALT_OUTPUTDIR/build.log fi控制台打印123456789101112#-- Build times ----------Target all_product_buildStart 2017-04-09 15:12:41End 2017-04-09 15:31:1700:00:59 corba00:03:08 hotspot00:00:13 jaxp00:00:16 jaxws00:13:42 jdk00:00:18 langtools00:18:36 TOTAL-------------------------这样就是编译成功了执行完后进入/openjdk7/build/j2sdk-image/bin1234./java -version openjdk version \"1.7.0-internal\" OpenJDK Runtime Environment (build 1.7.0-internal-root_2017_04_09_15_12-b00) OpenJDK 64-Bit Server VM (build 24.0-b56, mixed mode)jdk编译成功遇到的问题总结：问题一：123456789101112build-bootstrap-javac: [javac] Compiling 111 source files to /home/liurenjie/openjdk7/build-debug/langtools/build/bootstrap/classes [javac] /home/liurenjie/openjdk/langtools/src/share/classes/com/sun/tools/javac/comp/Resolve.java:2182: warning: [overrides] Class Resolve.InapplicableSymbolsError.Candidate overrides equals, but neither it nor any superclass overrides hashCode method [javac] private class Candidate &#123; [javac] ^ [javac] error: warnings found and -Werror specified [javac] 1 error [javac] 1 warning BUILD FAILED /home/liurenjie/openjdk/langtools/make/build.xml:452: The following error occurred while executing this line: /home/liurenjie/openjdk/langtools/make/build.xml:795: Compile failed; see the compiler error output for details.解决方案：换jdk http://www.oracle.com/technetwork/Java/javase/downloads/java-archive-downloads-javase7-521261.html#jdk-7u80-oth-JPR oracle jdk7问题二：12&gt;&amp;2 echo \"*** This OS is not supported:\" `uname -a`; exit 1; “*** This OS is not supported:\" 'uname -a'; exit 1;解决方案：修改hotspot/make/linux/MakefileSUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 3.7%或者注释掉123#ifeq ((DISABLE_HOTSPOT_OS_VERSION_CHECK)(EMPTY_IF_NOT_SUPPORTED),)# $(QUIETLY) &gt;&amp;2 echo \"*** This OS is not supported:\" uname -a; exit 1;#endif问题三：各种.h找不到解决方案：为bits,sys,gnu建立软链sudo ln -s /usr/include/x86_64-linux-gnu/gun /usr/include/gnu问题四：1./gamma: relocation error: /usr/lib/jvm/jdk1.7.0_80/jre/lib/amd64/libjava.so: symbol JVM_FindClassFromCaller, version SUNWprivate_1.1 not defined in file libjvm.so with link time reference解决方案：修改文件：hotspot/make/linux/Makefile去掉文件中所有的test_gamma即可###不过在后续编译好之后，发现hotspot无法启动，提示找不到gamma 命令问题五：12345Error: time is more than 10 years from present: 1136059200000 java.lang.RuntimeException: time is more than 10 years from present: 1136059200000 at build.tools.generatecurrencydata.GenerateCurrencyData.makeSpecialCaseEntry(GenerateCurrencyData.java:285) at build.tools.generatecurrencydata.GenerateCurrencyData.buildMainAndSpecialCaseTables(GenerateCurrencyData.java:225) at build.tools.generatecurrencydata.GenerateCurrencyData.main(GenerateCurrencyData.java:154)解决方案：通过修改CurrencyData.properties文件, 把10年之前的时间修改为10年之内即可 Index: openjdk/jdk/src/share/classes/java/util/CurrencyData.properties问题六：12345678910111213141516171819202122232425262728293031323334# # There is insufficient memory for the Java Runtime Environment to continue. # Native memory allocation (malloc) failed to allocate 1073741840 bytes for Chunk::new # An error report file with more information is saved as: # /home/liu/openjdk7/jdk/make/com/sun/jmx/hs_err_pid27588.log /home/liu/openjdk7/build/bin/java -XX:-PrintVMOptions -XX:+UnlockDiagnosticVMOptions -XX:-LogVMOutput -Xmx512m -Xms512m -XX:PermSize=32m -XX:MaxPermSize=160m -cp /home/liu/openjdk7/build/classes sun.rmi.rmic.Main -classpath \"/home/liu/openjdk7/build/classes\" \\ -d /home/liu/openjdk7/build/classes \\ -iiop -v1.2 \\ -standardPackage \\ javax.management.remote.rmi.RMIConnectionImpl Killed ###########log file################### # # There is insufficient memory for the Java Runtime Environment to continue. # Native memory allocation (malloc) failed to allocate 2147483664 bytes for Chunk::new # Possible reasons: # The system is out of physical RAM or swap space # In 32 bit mode, the process size limit was hit # Possible solutions: # Reduce memory load on the system # Increase physical memory or swap space # Check if swap backing store is full # Use 64 bit Java on a 64 bit OS # Decrease Java heap size (-Xmx/-Xms) # Decrease number of Java threads # Decrease Java thread stack sizes (-Xss) # Set larger code cache with -XX:ReservedCodeCacheSize= # This output file may be truncated or incomplete. # # Out of Memory Error (allocation.cpp:323), pid=29957, tid=140531611686656 # # JRE version: OpenJDK Runtime Environment (7.0) (build 1.7.0-internal-root_2017_03_30_20_45-b00) # Java VM: OpenJDK 64-Bit Server VM (24.0-b56 mixed mode linux-amd64 compressed oops) # Failed to write core dump. Core dumps have been disabled. To enable core dumping, try \"ulimit -c unlimited\" before starting Java again解决方案：这里我把swap空间 从原本的2g提升到了8g。 swap空间增加:http://blog.csdn.net/yc461515457/article/details/53610412根据以上的错误信息，发现使用到的是编译好的jdk，错误信息是配置更大的缓存。 修改了/home/liu/openjdk7/jdk/make/com/sun/jmx/ 路径下的Makefile 文件。1ifeq ((CROSS_COMPILE_ARCH),)新增：export JAVA_TOOLS_FLAGS=-XX:-PrintVMOptions -XX:+UnlockDiagnosticVMOptions -XX:-LogVMOutput -Xmx1024m -Xms512m -XX:PermSize=64m -XX:MaxPermSize=160m -XX:ReservedCodeCacheSize=2048m ---结束 RMIC = (RMIC_JAVA) (JAVA_TOOLS_FLAGS) -cp (OUTPUTDIR)/classes sun.rmi.rmic.Main endif然后再次编译就好了，也是弄了很久了。","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.liurenjie.top/tags/ubuntu/"},{"name":"openjdk","slug":"openjdk","permalink":"http://blog.liurenjie.top/tags/openjdk/"},{"name":"jdk","slug":"jdk","permalink":"http://blog.liurenjie.top/tags/jdk/"}]},{"title":"ubuntu下配置ss客户端","slug":"linux2017-03-19-1","date":"2017-03-19T15:47:40.000Z","updated":"2018-05-31T10:24:00.863Z","comments":true,"path":"posts/7464b8fe.html","link":"","permalink":"http://blog.liurenjie.top/posts/7464b8fe.html","excerpt":"shadowsocks install and configsudo apt-get install python-pip可能会出现pip版本问题，升级pip就好了如果遇到提示升级pip使用wget安装成功，具体如下：1234sudo apt-get updatesudo apt-get upgrade wget https://bootstrap.pypa.io/get-pip.py sudo python3 get-pip.py","text":"shadowsocks install and configsudo apt-get install python-pip可能会出现pip版本问题，升级pip就好了如果遇到提示升级pip使用wget安装成功，具体如下：1234sudo apt-get updatesudo apt-get upgrade wget https://bootstrap.pypa.io/get-pip.py sudo python3 get-pip.py安装：sudo pip install shadowsocks启动：sslocal -c /shadowsocks.json123INFO: loading config from shadowsocks.json 2017-03-19 13:11:41 INFO loading libcrypto from libcrypto.so.1.0.0 2017-03-19 13:11:41 INFO starting local at 127.0.0.1:1080编辑配置文件vim shadowsocks.json12345678&#123; \"server\" : \"123.123.213.213\", \"server_port\" : 6666, \"local_port\" : 1080, \"password\" : \"23333\", \"timeout\" : 600, \"method\" : \"aes-256-cfb\"&#125;设置开机自启启动脚本 vim /home/lujing/vpn.shsslocal -c /shadowsocks.json $1在/etc/rc.local 的文件让shadowsocks开机启动。sudo gedit /etc/rc.local在exit 0 前面加上 sudo sh /home/lujing/vpn.sh start也可以查看 ps -ef | grep sslocal 查看sslocal是否在运行chrome浏览器代理使用chrome一个插件地址：https://github.com/FelisCatus/SwitchyOmega/releasesSwitchyOmega.crx 然后拖入chrome的扩展程序中就好了配置新建情境模式，默认代理服务器，名字：ss，创建。代理服务器配置：网址协议 代理协议 代理服务器 代理端口默认 socks5 127.0.0.1 1080新建情景模式，自动切换模式，名字:shadowsock,创建。规则列表设置，autoproxy，规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt立即更新情景模式。规则列表规则 选择ss。 默认情景模式选择 直接链接。点击右上叫的圆点，选择shadowsock代理。ok，试试google。终端代理中间件代理privoxy,把http，https数据导向shadowsocks。sudo apt-get install privoxy修改vim /etc/privoxy/config文件找到listen-address 确认监听号如：123#listen-address [::1]:8118##listen-address localhost:8118找到这个 forward-socks4, forward-socks4a, forward-socks5 and forward-socks5t在这一节这行 #forward localhost/换行追加 forward-socks5 / 127.0.0.1:1080配置完成，重启一下privoxy。sudo /etc/init.d/privoxy restart接着配置终端环境变量，export http_proxy=&quot;127.0.0.1:8118&quot;export https_proxy=&quot;127.0.0.1:8118&quot;然后试一下效果 wget www.google.com 结果：1234567--2017-03-19 12:38:20-- http://www.google.com/ 正在连接 127.0.0.1:8118... 已连接。 已发出 Proxy 请求，正在等待回应... 200 OK 长度： 10222 (10.0K) [text/html] 正在保存至: “index.html” index.html 100%[===================&gt;] 9.98K --.-KB/s in 0s 2017-03-19 12:38:23 (206 MB/s) - 已保存 “index.html” [10222/10222])终端搞定。开机自启为了方便在/etc/rc.local中添加命令，注意在exit 0之前。sudo /etc/init.d/privoxy restart在/etc/profile的末尾添加export http_proxy=&quot;127.0.0.1:8118&quot;export https_proxy=&quot;127.0.0.1:8118&quot;ok.","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.liurenjie.top/tags/ubuntu/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.liurenjie.top/tags/shadowsocks/"}]},{"title":"Ubuntu 16.04配置Shadowsocks和Privoxy实现浏览器和终端代理","slug":"shadowsocks2017-03-18-1","date":"2017-03-18T18:52:19.000Z","updated":"2018-05-31T10:24:00.877Z","comments":true,"path":"posts/36a5596d.html","link":"","permalink":"http://blog.liurenjie.top/posts/36a5596d.html","excerpt":"这几天想配置PHP Laravel框架，Laravel框架需要Composer安装。结果安装Composer的时候遭遇到了GFW，光在浏览器上穿墙还不够，还要在终端上穿墙。使用Shadowsocks在浏览器上穿墙很简单，但是在终端穿墙以前没接触过，这次花了一晚上搞定了。","text":"这几天想配置PHP Laravel框架，Laravel框架需要Composer安装。结果安装Composer的时候遭遇到了GFW，光在浏览器上穿墙还不够，还要在终端上穿墙。使用Shadowsocks在浏览器上穿墙很简单，但是在终端穿墙以前没接触过，这次花了一晚上搞定了。安装Shadowsocks既然是用Shadowsocks穿墙，那么首先需要安装Shadowsocks。在维基百科上对Shadowsocks的描述如下：Shadowsocks使用自行设计的协议进行加密通信。加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。然而协议对双方的身份验证仅限于预共享密钥（pre-shared keys），亦无完全前向保密（perfect forward secrecy），也未曾有安全专家公开分析或评估协议及其实现。Shadowsocks不能替代TLS或者VPN，本质上只是设置了密码的网络代理协议，不能用作匿名通信方案，该协议的目标不在于提供完整的通信安全机制，主要是为了协助上网用户在严苛的网络环境中突破封锁。在某些极端的环境下，通过深度包检测（DPI）也有可能识别出协议特征。为了确保安全，用户应做好额外的加密和验证措施，以免泄露信息，无论使用的服务器来源是否可靠。通过客户端以指定的密码、加密方式和端口连接服务器，成功连接到服务器后，客户端在用户的电脑上构建一个本地socks5代理。使用时将流量分到本地SOCKS5代理，客户端将自动加密并转发流量到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。虽然不是一个完整的通信安全机制，不过只要能突破封锁就可以了。Shadowsocks的安装很简单。~$ sudo apt-get install python-gevent python-pip~$ sudo pip install shadowsocks安装后需要对Shadowsocks进行配置，在/etc目录下新建shadowsocks.json文件，添加以下内容。12345678910&#123; \"server\": \"your server ip\", \"server_port\": 15216, \"local_address\": \"127.0.0.1\", \"local_port\": 1080, \"password\": \"your password\", \"method\": \"aes-256-cfb\", \"fast_open\": true, \"workers\": 1&#125;随后就可以启动Shadowsocks了。~$ sslocal -c /etc/shadowsocks.json但是这样每次启动后都需要手动输一次命令，比较麻烦，所以设置为启动时自动运行。在/etc/rc.local中添加如下命令，注意在exit 0之前。sudo sslocal -c /etc/shadowsocks.json注意，这里必须用sudo才行，具体原因不明。至此，Shadowsocks已经配置成功。Chrome穿墙使用Chrome穿墙需要用到一个插件——Proxy SwitchyOmega。安装好这个插件以后，按照如下配置这个插件。 平时使用的使用使用自动切换模式即可，遇到实在打不开的网页，直接使用Shadowsocks模式。终端穿墙浏览器能穿墙就已经能满足绝大多数需求了，但是有的时候终端也必须穿墙，就比如Composer。关于终端穿墙，本人尝试了很多种方案，比如Privoxy、Proxychains和Polipo，最后觉得还是Privoxy最好。为什么终端需要单独穿墙呢？难道Shadowsock不能“全局”代理么？这个问题当时困惑了我很久，最后一句话点醒了我。 Shadowsocks是一个使用SOCKS5（或者SOCK4之类）协议的代理，它只接受SOCKS5协议的流量，不接受HTTP或者HTTPS的流量。所以当你在Chrome上能穿墙的时候，是Proxy SwitchyOmega插件把HTTP和HTTPS流量转换成了SOCKS协议的流量，才实现了Shadowsocks的代理。而终端是没有这样的协议转换的，所以没法直接使用Shadowsock进行代理。这时候就需要一个协议转换器，这里我用了Privoxy。那么Privoxy到底是什么呢？维基百科上是这么说的。Privoxy是一款带过滤功能的代理服务器，针对HTTP、HTTPS协议。通过Privoxy的过滤功能，用户可以保护隐私、对网页内容进行过滤、管理cookies，以及拦阻各种广告等。Privoxy可以用作单机，也可以应用到多用户的网络。修改HTTP请求头的字段，如referrer和user agent，从而隐藏用户上一个查看的网页和用户正在使用的浏览器。安装Privoxy很简单。~$ sudo apt-get install privoxy安装好后进行配置，Privoxy的配置文件在/etc/privoxy/config，这个配置文件中注释很多。找到4.1. listen-address这一节，确认监听的端口号。找到5.2. forward-socks4, forward-socks4a, forward-socks5 and forward-socks5t这一节，加上如下配置，注意最后的点号。有关Privoxy的配置就结束了，重启一下Privoxy。~$ sudo /etc/init.d/privoxy restart接着配置一下终端的环境，需要如下两句。~$ export http_proxy=&quot;127.0.0.1:8118&quot;~$ export https_proxy=&quot;127.0.0.1:8118&quot;然后就可以测试一下穿墙效果了。12345678910111213141516~$ wget http://www.google.com--2016-01-06 23:59:30-- http://www.google.com/正在连接 127.0.0.1:8118... 已连接。已发出 Proxy 请求，正在等待回应... 200 OK长度： 未指定 [text/html]正在保存至: “index.html”[ &lt;=&gt; ] 154,759 --.-K/s 用时 0s 2016-01-06 23:59:31 (842 MB/s) - “index.html” 已保存 [154759]~$ wget https://www.google.com--2016-01-06 23:59:36-- https://www.google.com/正在连接 127.0.0.1:8118... 已连接。已发出 Proxy 请求，正在等待回应... 200 OK长度： 未指定 [text/html]正在保存至: “index.html.1”[ &lt;=&gt; ] 154,786 78.5KB/s 用时 1.9s2016-01-06 23:59:39 (78.5 KB/s) - “index.html.1” 已保存 [154786]终端穿墙搞定！为了方便还是在/etc/rc.local中添加如下命令，注意在exit 0之前。sudo /etc/init.d/privoxy start在/etc/profile的末尾添加如下两句。export http_proxy=&quot;127.0.0.1:8118&quot;export https_proxy=&quot;127.0.0.1:8118&quot;ubuntu下通过privoxy将Socks代理转换为Http代理：http://www.linuxdiyf.com/linux/13715.html安装net-speeder，加速Shadowsocks：http://www.linuxdiyf.com/linux/15304.htmlubuntu服务器搭建Shadowsocks服务：http://www.linuxdiyf.com/linux/15100.htmlLinux下使用shadowsocks（以ubuntu14为例，非服务器）：http://www.linuxdiyf.com/linux/14658.htmlUbuntu下配置shadowsocks-libv客户端：http://www.linuxdiyf.com/linux/14544.html","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.liurenjie.top/categories/shadowsocks/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.liurenjie.top/tags/ubuntu/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.liurenjie.top/tags/shadowsocks/"},{"name":"privoxy","slug":"privoxy","permalink":"http://blog.liurenjie.top/tags/privoxy/"}]},{"title":"tomcat+nginx+redis实现均衡负载、session共享(二)","slug":"nginx2017-03-14-7","date":"2017-03-14T20:33:32.000Z","updated":"2018-06-01T01:42:51.443Z","comments":true,"path":"posts/6ffc91de.html","link":"","permalink":"http://blog.liurenjie.top/posts/6ffc91de.html","excerpt":"redis简介及下载安装作为这次的主角，相信大家对redis应该都一定印象，redis是一款开源的高性能key-value数据库，拥有丰富的键值储存类型，并提供多种语言的API。与一般数据库不同，redis是使用内存作为主存，而使用硬盘来实现数据持久化，而且redis是周期性的将数据写到硬盘上。这就意味着一旦我们服务器出现断电、重启之类的情况，我们很可能会出现数据丢失的情况，所以不建议使用redis来存放关键的数据。当然，也正因为redis读写数据都使用内存，所以它的速度是非常快的，很适合我们来存放一些临时性的数据。此外，redis能实现的作用很多，诸如队列、缓存之类的，但我也还没使用过，无法在这里为大家说明，但不影响我们今天的session共享功能。","text":"redis简介及下载安装作为这次的主角，相信大家对redis应该都一定印象，redis是一款开源的高性能key-value数据库，拥有丰富的键值储存类型，并提供多种语言的API。与一般数据库不同，redis是使用内存作为主存，而使用硬盘来实现数据持久化，而且redis是周期性的将数据写到硬盘上。这就意味着一旦我们服务器出现断电、重启之类的情况，我们很可能会出现数据丢失的情况，所以不建议使用redis来存放关键的数据。当然，也正因为redis读写数据都使用内存，所以它的速度是非常快的，很适合我们来存放一些临时性的数据。此外，redis能实现的作用很多，诸如队列、缓存之类的，但我也还没使用过，无法在这里为大家说明，但不影响我们今天的session共享功能。首先我们先下载redis，这是windows版本的下载地址 https://github.com/ServiceStack/redis-windows。可以点击右边下载全部文件，但感觉没必要，而且下载速度偏慢，建议进入downloads里面下载我们所需的redis包即可。redis在windows下是免安装的，下载完成后，解压，将文件夹复制到自己某个盘中就好了。解压后是这个样子的。一开始redis是默认不需要密码，如果想要设置密码，可以进入redis.windows.conf文件下找到requirepass，删除前面的#号，在其后面便可以设置密码，我这里设成了123456。下面我们打开redis。首先打开cmd，进入我们redis目录下，输入redis-server.exe redis.windows.conf。出现下面界面，则打开成功。(不可偷懒想双击redis-server.exe完事，这样虽然也能打开，但不会加载配置文件)。另外和别的数据库一样，我们需要安装一个辅助的可视化工具Redis Desktop Manager，这是下载地址：http://redisdesktop.com/download。我们下载windows版本，安装完成后，还没有任何连接对象，那就让我们给它添加一个。点击下方的connect to redis server，出现个弹出框。然后Name我们可以随便输，Host添我们redis服务器的ip地址，本地可以直接填写localhost，端口默认为6379，Auth就是密码，不是必填项，如果没设置密码可不填，点击OK，建立完成。至此，我们的准备工作都已经完成，下面开始我们的spring与redis的整合之旅。Spring与Redis的整合之旅这是上篇文章结束时我的项目目录。其实Spring本身就有提供对redis的支持，就是spring-session，我们只需将这个在pom.xml添加如下代码，maven便会自己下载所需的jar包及依赖包。123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.1.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt;随后我们在resources文件夹中新建一个redis.properties，往里面添加如下内容。12345678#主机地址redis_host=localhost#端口redis_port=6379#密码redis_password=123456#超时redis_timeout=20000再新建一个spring-redis.xml，往里面添加我们redis相关的配置。其中maxInactiveIntervalInSeconds是设置session有效时间，以秒为单位，但实际上无论怎么设，session真实有效时间还是会比我们设置的稍微长一些。1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- session设置 --&gt; &lt;bean class=\"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration\"&gt; &lt;property name=\"maxInactiveIntervalInSeconds\" value=\"3600\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- redis连接池 --&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"/&gt; &lt;!-- redis连接工厂 --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"hostName\" value=\"$&#123;redis_hostName&#125;\"/&gt; &lt;property name=\"port\" value=\"$&#123;redis_port&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;redis_password&#125;\"/&gt; &lt;property name=\"timeout\" value=\"$&#123;redis_timeout&#125;\"/&gt; &lt;property name=\"poolConfig\" ref=\"poolConfig\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;添加完成后，别忘了还要在spring.xml和web.xml引入我们新添加的文件，引入代码这里就不给出了。 最后我们还需要在web.xml中加入spring的session过滤器，我个人理解这个过滤器的作用是告诉spring来接管对session管理与创建工作。123456789&lt;!--session过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;完成这一步以后，我们对redis的集成就完成了，接下来我们测试一下。Session共享测试为了完成测试，我先在IndexController中添加了两个简单方法，一个是登录方法，一个是进入用户中心方法。需要注意的是如果要往redis中存入对象，则需要改对象序列化才能存入。我这里为了方便，就用fastjson将对象转为字符串存入了，查看起来也方便点。另外个人中心页面很简单。现在已经完成测试前的全部工作了，开始测试吧。启动tomcat1,在浏览器中输入localhost:8080,进入我们的登录页面，登录页面代码就不贴出了，就是ajax提交而已。输入我们的用户名和密码。登录。看到我们登录成功了，用户个人中心能成功显示我们的用户名。再看看我们redis服务器，可以看到里面已经添加了一些数据，有些session是spring自己添加的，具体什么意思我也不是很清楚，但我们找一下，就可以找到我们刚刚添加的session。其中右上角的TIL是我们session剩余有效时间。那么这session是否能被共享呢? 让我们老规矩，复制tomcat1的项目，到tomcat2中去，修改个别字以区分页面。启动项目，直接在浏览器中输入个人中心的路径，localhost:8081/userCenter。可以看到没报任何空指针错误，直接就进入了个人中心页面(当然要在同个浏览器中哦)。共享成功。随后打开我们上次配置好的nginx，进入登录界面，进行登录步骤，我们就可以看到我们可能在tomcat1登录，进入tomcat2的个人中心，当然可能反之，刷新时个人中心页面，会看见两个tomcat的页面在间隔得显示，测试成功。再补充个上次漏掉的，这时我们可以关闭其中一个服务器，我关了tomcat1，再多次刷新页面，会发现接下来出现的都是tomcat2的页面，这时必然的，但是时而快时而慢。这其中原因是当nginx将请求转发到tomcat2时，服务器当然能做出立即性响应，但要是转到了tomcat1，就会出现一段长达1分多钟的等待响应过程，这显然我们是不能接受的。对此我们需要对ngin配置进行写修改。在这里先介绍几个标签。proxy_connect_timeout：与服务器连接的超时时间，默认60sfail_timeout：当该时间内服务器没响应，则认为服务器失效，默认10smax_fails：允许连接失败次数，默认为1这里我们所需等待时间 = proxy_connect_timeout + fail_timeout*max_fails，所以我如下配置只需等待3秒，nginx便会将请求转给tomcat2,还是在能接受范围内的。小结该说的在前文也说了，总而言之，spring已经为我们的session共享提供了很好的支持，我们只需好好利用它就好了。在此demo源码奉上：http://download.csdn.net/detail/zhrxidian/9520968。后记前些天遇到一个问题，有个功能能设置调度任务，但不能设置同一个时间点，这样就需要将前边设置的时间保存下来。当时的想法是新建一张表来储存设置的时间，但总有杀鸡用牛刀的感觉。后来工头提醒项目已经有了redis，那就物尽其用，就被叫去做redis实现数据缓存功能。好在redis提供了java客户端开发包，名曰jedis，下星期会比较忙，等过段时间再分享下使用jedis缓存数据的过程。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/categories/nginx/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://blog.liurenjie.top/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/tags/nginx/"},{"name":"redis","slug":"redis","permalink":"http://blog.liurenjie.top/tags/redis/"}]},{"title":"报错ERR Unsupported CONFIG parameter","slug":"java2017-03-14-6","date":"2017-03-14T18:37:44.000Z","updated":"2018-06-01T01:42:51.397Z","comments":true,"path":"posts/d70f9175.html","link":"","permalink":"http://blog.liurenjie.top/posts/d70f9175.html","excerpt":"","text":"问题：报错ERR Unsupported CONFIG parameter: notify-keyspace-events原因：Redis版本与spring session冲突解决方案：更换redis版本为2.8以上","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"exception","slug":"exception","permalink":"http://blog.liurenjie.top/tags/exception/"}]},{"title":"No WebApplicationContext found报错解决","slug":"java2017-03-14-5","date":"2017-03-14T17:24:27.000Z","updated":"2018-06-01T01:42:51.392Z","comments":true,"path":"posts/505e579.html","link":"","permalink":"http://blog.liurenjie.top/posts/505e579.html","excerpt":"分析了下，我是在SystemLaunchListener里面执行的时候，发现ContextLoaderListener 这个监听器没有注册。难道是因为这两个listener是先后执行的？调了下这个两个监听器的顺序，把spring的监听器放在了最前面。重启tomcat，就没有这个报错了。​ 网上搜了下web.xml文件里listener的执行顺序。下面是一个可信的说法：​ 在Java web规范中说明.按照listner,filter,servlet的顺序初始化.其中listener是按照在web.xml中的申明顺序执行的.不存在并发的的情况.","text":"分析了下，我是在SystemLaunchListener里面执行的时候，发现ContextLoaderListener 这个监听器没有注册。难道是因为这两个listener是先后执行的？调了下这个两个监听器的顺序，把spring的监听器放在了最前面。重启tomcat，就没有这个报错了。​ 网上搜了下web.xml文件里listener的执行顺序。下面是一个可信的说法：​ 在Java web规范中说明.按照listner,filter,servlet的顺序初始化.其中listener是按照在web.xml中的申明顺序执行的.不存在并发的的情况.123456789101112131415161718192021java.lang.IllegalStateException: No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered? at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:252) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:474) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:624) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:349) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:495) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:767) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1347) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745)","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"exception","slug":"exception","permalink":"http://blog.liurenjie.top/tags/exception/"}]},{"title":"tomcat+nginx+redis实现均衡负载、session共享(一)","slug":"nginx2017-03-14-4","date":"2017-03-14T16:57:53.000Z","updated":"2018-06-01T01:42:51.436Z","comments":true,"path":"posts/c0cd0abc.html","link":"","permalink":"http://blog.liurenjie.top/posts/c0cd0abc.html","excerpt":"在项目运营时，我们都会遇到一个问题，项目需要更新时，我们可能需先暂时关闭下服务器来更新。但这可能会出现一些状况:1.用户还在操作，被强迫终止了(我们可以看日志等没人操作的时候更新，但总可能会有万一)2.不知道的用户可能会想网站是不是被攻击了，降低了对网站的信任程度，从而导致失去部分潜在客户，这点尤其对金融互联网公司不利。在查了一些资料后，决定采用Tomcat + Nginx + Redis来实现负载均衡和session共享。下面记录下我的实践过程，如有错误不足之处欢迎大神指点，不喜勿喷。","text":"在项目运营时，我们都会遇到一个问题，项目需要更新时，我们可能需先暂时关闭下服务器来更新。但这可能会出现一些状况:1.用户还在操作，被强迫终止了(我们可以看日志等没人操作的时候更新，但总可能会有万一)2.不知道的用户可能会想网站是不是被攻击了，降低了对网站的信任程度，从而导致失去部分潜在客户，这点尤其对金融互联网公司不利。在查了一些资料后，决定采用Tomcat + Nginx + Redis来实现负载均衡和session共享。下面记录下我的实践过程，如有错误不足之处欢迎大神指点，不喜勿喷。Nginx简单介绍及开启Nginx是一款轻量级兼备高性能的Http和反向代理服务器。所谓反向代理就是指在用户发起访问请求，由代理服务器接收，然后将请求转发给正式服务器，并且将正式服务器处理完的数据返回给客户端，此时代理服务器就表现为一个服务器。这么做看起来多经过了一步，稍显麻烦，但实则是好处多多，在下面的demo中我会将其体现出来。首先我们去Nginx官网下载个Nginx，我这是在自己电脑上，所以当然下载的是windows版本的。下载完成后直接放在某个盘中即可，不需要安装。接下去我们打开cmd，进入nginx的目录下，输入start nginx。我们可以看到一个窗口一闪而过，这样nginx就已经被开启了，我们在任务管理器中可以找到它的进程。现在我们在浏览器中输入localhost。可以看到出现一个页面，虽然简陋了点，但这确确实实就是nginx的欢迎页面，就类似tomcat刚启动完成的locahost:8080的欢迎页面。使用Nginx实现反向代理现在我们搭建一个基于SpringMVC ＋Spring + Mybaties框架的maven项目，搭建过程不加以赘述。功能很简单，就是能跳转到一个页面就行了，当然也可以使用别的框架。运行demo，我这tomcat端口是8080，在浏览器输入localhost:8080，出现我们的页面。这时我们还是直接访问tomcat服务器的，现在我想通过nginx访问tomcat，即输入localhost就能显示我们demo的页面。这就要我们去修改nginx的核心配置文件，在其目录下的conf文件夹下的nginx.conf文件，那么首先我们就要了解该文件中一些节点的作用。worker_processes：工作进程个数，可配置多个worker_connections:单个进程最大连接数server:每一个server相当于一个代理服务器lister:监听端口，默认80server_name:当前服务的域名，可以有多个，用空格分隔(我们是本地所以是localhost)location：表示匹配的路径，这时配置了/表示所有请求都被匹配到这里index：当没有指定主页时，默认会选择这个指定的文件，可多个，空格分隔proxy_pass：请求转向自定义的服务器列表upstream name{ }:服务器集群名称知道了节点作用后，我们就知道我们需要修改的文件中的server部分，这是它原有的代码，我删除了它注释部分。现在我们就能明白为什么输入localhost，它访问的是它欢迎页面即index.html。下面我们对这段代码进行一些小小修改。就是将请求转向我们定义的服务器。随后在cmd中输入命令nginx -s reload即可重启nginx。重启后，我们再输入localhost，可以看到跳转到的页面是我们demo的。至此，反向代理已完成，这样所有请求都需经过代理服务器才能访问到正式服务器，某种程度上可以保护网站安全。使用Nginx实现负载均衡负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中。负载均衡的优势在访问量少或并发小的时候可能并不明显，且不说淘宝双11、铁道部抢票这种级别的访问量、高并发，就是一般网站的抢购活动时，也会给服务器造成很大压力，可能会造成服务器崩溃。而负载均衡可以很明显的减少甚至消除这种情况的出现，下面我们说说实现方法。首先我们再开启一个tomcat服务器，这里区分一下就叫tomcat2吧，原先的叫tomcat1。将tomcat1上的项目，拷贝到tomcat2上，稍微修改下页面上的文字以便等下区分我们的请求被分发到了哪个tomcat上。tomcat2端口我这里为8081。在浏览器中输入localhost:8081。服务器准备好了，我们要在server外部定义个服务器集群，即用到了上文中提到的upstream 标签。服务器集群名字取为test。同时我们需要再修改下server，将定向的路径转到问你服务器集群上。重启下nginx，在浏览器输入localhost，再多刷新几次，可以看到两个页面在来回切换。这样即实现了负债均衡。假设我们服务器在运行过程中，其中一个tomcat挂了，仍然还有另一个可以访问。更新的时候也能先关闭只其中一个，轮流更新。另外还能有效缓解服务器压力，是不是很棒呢?当然，以上nginx的配置是简单化的，实际上我们还可以配置nginx对静态资源的缓存等等，在此就不多加演示了。小结花了好些时间，总算陆陆续续要写好了，在此小结一下。nginx作为一个反向代理服务器，能缓存我们项目的静态文件，并实现反向代理与均衡负载，可以有效减少服务器压力，即使项目不大，也可以使用。大家另外应该都还发现了个问题，虽然这样请求能分别请求到两个tomcat上，如果是一般不需身份校检的或什么认证的方法尚可，但如果出现这类情况：我们在tomcat1上进行了登录，这时用户session当然是存在tomcat1上的，而这时进入个人中心的请求请求到tomcat2上了，这时就会出现问题了。tomcat2会告诉你还未登录，这显然不是我们想看到的。这就涉及到session共享了，如何让两个服务器上的session共用。我这里放到下次再说，作为码农比较忙，可能要过个好几天。另外我将这次的demo源码上传了，下次还要用，nginx配置就不传了，大家自己多动手试验。附下载地址：http://download.csdn.net/detail/zhrxidian/9517266","categories":[{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/categories/nginx/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://blog.liurenjie.top/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/tags/nginx/"},{"name":"redis","slug":"redis","permalink":"http://blog.liurenjie.top/tags/redis/"}]},{"title":"Nginx+Tomcat搭建高性能负载均衡集群","slug":"nginx2017-03-14-3","date":"2017-03-14T16:07:43.000Z","updated":"2018-06-01T01:42:51.430Z","comments":true,"path":"posts/8742f319.html","link":"","permalink":"http://blog.liurenjie.top/posts/8742f319.html","excerpt":"工具：​ nginx-1.8.0 apache-tomcat-6.0.33目标实现高性能负载均衡的Tomcat集群：","text":"工具：​ nginx-1.8.0 apache-tomcat-6.0.33目标实现高性能负载均衡的Tomcat集群：步骤首先下载Nginx，要下载稳定版：然后解压两个Tomcat，分别命名为apache-tomcat-6.0.33-1和apache-tomcat-6.0.33-2：然后修改这两个Tomcat的启动端口，分别为18080和28080，下面以修改第一台Tomcat为例，打开Tomcat的conf目录下的server.xml：共需修改3处端口：当然第二台Tomcat也一样，如下图：然后启动两个Tomcat，并访问，看是否正常：然后修改上面两个Tomcat的默认页面（为了区分下面到底访问的是那一台Tomcat，随便改一下即可）： 改完以后，进行访问，如下图：OK，现在我们可以开始配置Nginx来实现负载均衡了，其实非常的简单，只需要配置好Nginx的配置文件即可：配置如下（这里只进行了简单的配置，实际生产环境可以进行更详细完善配置）：123456789101112131415161718192021222324252627282930313233worker_processes 1;#工作进程的个数，一般与计算机的cpu核数一致 events &#123; worker_connections 1024;#单个进程最大连接数（最大连接数=连接数*进程数） &#125; http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream;#默认文件类型 sendfile on;#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 keepalive_timeout 65; #长连接超时时间，单位是秒 gzip on;#启用Gizp压缩 #服务器的集群 upstream netitcast.com &#123; #服务器集群名字 server 127.0.0.1:18080 weight=1;#服务器配置 weight是权重的意思，权重越大，分配的概率越大。 server 127.0.0.1:28080 weight=2; &#125; #当前的Nginx的配置 server &#123; listen 80;#监听80端口，可以改成其他端口 server_name localhost;############## 当前服务的域名 location / &#123; proxy_pass http://netitcast.com; proxy_redirect default; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125;核心配置如下：到此配置完成，下面开始演示负载均衡。首先，我们启动Nginx：然后我们即可输入：localhost/index.jsp查看运行状况了第一次访问，发现访问的是Tomcat2上的程序：然后刷新，访问的还是Tomcat2上的程序：再刷新，发现变为了Tomcat1上的程序：再刷新，发现又变为了Tomcat2上的程序:到此，我们利用Nginx已经实现了负载均衡的Tomcat集群。我们不断的刷新，发现访问Tomcat2的概率大概是Tomcat1的2倍，这是因为我们在Nginx中配置的两台Tomcat的权重起的作用，如下图：总结 谁能想到实现一个高性能的负载均衡集群会如此简单。Nginx的功能如此强大，配置却如此简单，我们还有什么理由拒绝它呢？这比我们动不动就十多万至几十万人民币的F5 BIG-IP、NetScaler等硬件负载均衡交换机廉价了不知多少。此外，大家别忘了Nginx不仅仅是一个反向代理服务器，它本身也可以托管网站，作为Web服务器，进行Http服务处理。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/categories/nginx/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://blog.liurenjie.top/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.liurenjie.top/tags/nginx/"}]},{"title":"MySQL中select * for update锁表的范围","slug":"mysql2017-03-14-2","date":"2017-03-14T11:30:35.000Z","updated":"2018-05-31T10:24:00.869Z","comments":true,"path":"posts/c5efe366.html","link":"","permalink":"http://blog.liurenjie.top/posts/c5efe366.html","excerpt":"由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行TableLock (将整个资料表单给锁住)。 举个例子: 假设有个表单products ，里面有id跟name二个栏位，id是主键。例1: (明确指定主键，并且有此笔资料，row lock)SELECT * FROM products WHERE id=&#39;3&#39; FOR UPDATE;SELECT * FROM products WHERE id=&#39;3&#39; and type=1 FOR UPDATE;","text":"由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行TableLock (将整个资料表单给锁住)。 举个例子: 假设有个表单products ，里面有id跟name二个栏位，id是主键。例1: (明确指定主键，并且有此笔资料，row lock)SELECT * FROM products WHERE id=&#39;3&#39; FOR UPDATE;SELECT * FROM products WHERE id=&#39;3&#39; and type=1 FOR UPDATE;例2: (明确指定主键，若查无此笔资料，无lock)SELECT * FROM products WHERE id=&#39;-1&#39; FOR UPDATE;例2: (无主键，table lock)SELECT * FROM products WHERE name=&#39;Mouse&#39; FOR UPDATE;例3: (主键不明确，table lock)SELECT * FROM products WHERE id&lt;&gt;&#39;3&#39; FOR UPDATE;例4: (主键不明确，table lock)SELECT * FROM products WHERE id LIKE &#39;3&#39; FOR UPDATE;注1: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。注2: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。在MySql 5.0中测试确实是这样的另外：MyAsim 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改（修改、删除） 。**是表级锁时，不管是否查询到记录，都会锁定表。**","categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"}]},{"title":"线程同步synchronized和volatile","slug":"java2017-03-14-1","date":"2017-03-14T11:01:35.000Z","updated":"2018-05-31T10:24:00.885Z","comments":true,"path":"posts/7a0cd0da.html","link":"","permalink":"http://blog.liurenjie.top/posts/7a0cd0da.html","excerpt":"上篇通过一个简单的例子说明了线程安全与不安全，在例子中不安全的情况下输出的结果恰好是逐个递增的(其实是巧合，多运行几次，会产生不同的输出结果)，为什么会产生这样的结果呢，因为建立的Count对象是线程共享的，一个线程改变了其成员变量num值，下一个线程正巧读到了修改后的num，所以会递增输出。","text":"上篇通过一个简单的例子说明了线程安全与不安全，在例子中不安全的情况下输出的结果恰好是逐个递增的(其实是巧合，多运行几次，会产生不同的输出结果)，为什么会产生这样的结果呢，因为建立的Count对象是线程共享的，一个线程改变了其成员变量num值，下一个线程正巧读到了修改后的num，所以会递增输出。要说明线程同步问题首先要说明Java线程的两个特性，可见性和有序性。多个线程之间是不能直接传递数据交互的，它们之间的交互只能通过共享变量来实现。拿上篇博文中的例子来说明，在多个线程之间共享了Count类的一个对象，这个对象是被创建在主内存(堆内存)中，每个线程都有自己的工作内存(线程栈)，工作内存存储了主内存Count对象的一个副本，当线程操作Count对象时，首先从主内存复制Count对象到工作内存中，然后执行代码count.count()，改变了num值，最后用工作内存Count刷新主内存Count。当一个对象在多个内存中都存在副本时，如果一个内存修改了共享变量，其它线程也应该能够看到被修改后的值，此为可见性。多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。本文讲述了JDK5.0之前传统线程的同步方式，更高级的同步方式可参见Java线程(八)：锁对象Lock-同步问题更完美的处理方式。下面同样用代码来展示一下线程同步问题。TraditionalThreadSynchronized.java：创建两个线程，执行同一个对象的输出方法。123456789101112131415161718192021222324public class TraditionalThreadSynchronized &#123; public static void main(String[] args) &#123; final Outputter output = new Outputter(); new Thread() &#123; public void run() &#123; output.output(\"zhangsan\"); &#125; &#125;.start(); new Thread() &#123; public void run() &#123; output.output(\"lisi\"); &#125; &#125;.start(); &#125; &#125; class Outputter &#123; public void output(String name) &#123; // TODO 为了保证对name的输出不是一个原子操作，这里逐个输出name的每个字符 for(int i = 0; i &lt; name.length(); i++) &#123; System.out.print(name.charAt(i)); // Thread.sleep(10); &#125; &#125; &#125;运行结果： zhlainsigsan显然输出的字符串被打乱了，我们期望的输出结果是zhangsanlisi，这就是线程同步问题，我们希望output方法被一个线程完整的执行完之后再切换到下一个线程，Java中使用synchronized保证一段代码在多线程执行时是互斥的，有两种用法：使用synchronized将需要互斥的代码包含起来，并上一把锁。1234567&#123; synchronized (this) &#123; for(int i = 0; i &lt; name.length(); i++) &#123; System.out.print(name.charAt(i)); &#125; &#125; &#125;这把锁必须是需要互斥的多个线程间的共享对象，像下面的代码是没有意义的。12345678&#123; Object lock = new Object(); synchronized (lock) &#123; for(int i = 0; i &lt; name.length(); i++) &#123; System.out.print(name.charAt(i)); &#125; &#125; &#125;每次进入output方法都会创建一个新的lock，这个锁显然每个线程都会创建，没有意义。将synchronized加在需要互斥的方法上。123456public synchronized void output(String name) &#123; // TODO 线程输出方法 for(int i = 0; i &lt; name.length(); i++) &#123; System.out.print(name.charAt(i)); &#125; &#125;这种方式就相当于用this锁住整个方法内的代码块，如果用synchronized加在静态方法上，就相当于用××××.class锁住整个方法内的代码块。使用synchronized在某些情况下会造成死锁，死锁问题以后会说明。使用synchronized修饰的方法或者代码块可以看成是一个原子操作。​ 每个锁对象(JLS中叫monitor)都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个线程被唤醒(notify)后，才会进入到就绪队列，等待CPU的调度，反之，当一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒，这个涉及到线程间的通信，下一篇博文会说明。看我们的例子，当第一个线程执行输出方法时，获得同步锁，执行输出方法，恰好此时第二个线程也要执行输出方法，但发现同步锁没有被释放，第二个线程就会进入就绪队列，等待锁被释放。一个线程执行互斥代码过程如下：获得同步锁；清空工作内存；从主内存拷贝对象副本到工作内存；执行代码(计算或者输出等)；刷新主内存数据；释放同步锁。所以，synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。​ volatile是第二种Java多线程同步的机制，根据JLS(Java LanguageSpecifications)的说法，一个变量可以被volatile修饰，在这种情况下内存模型(主内存和线程工作内存)确保所有线程可以看到一致的变量值，来看一段代码：12345678910class Test &#123; static int i = 0, j = 0; static void one() &#123; i++; j++; &#125; static void two() &#123; System.out.println(\"i=\" + i + \" j=\" + j); &#125; &#125;一些线程执行one方法，另一些线程执行two方法，two方法有可能打印出j比i大的值，按照之前分析的线程执行过程分析一下：将变量i从主内存拷贝到工作内存；改变i的值；刷新主内存数据；将变量j从主内存拷贝到工作内存；改变j的值；刷新主内存数据；这个时候执行two方法的线程先读取了主存i原来的值又读取了j改变后的值，这就导致了程序的输出不是我们预期的结果，要阻止这种不合理的行为的一种方式是在one方法和two方法前面加上synchronized修饰符：12345678910class Test &#123; static int i = 0, j = 0; static synchronized void one() &#123; i++; j++; &#125; static synchronized void two() &#123; System.out.println(\"i=\" + i + \" j=\" + j); &#125; &#125;根据前面的分析，我们可以知道，这时one方法和two方法再也不会并发的执行了，i和j的值在主内存中会一直保持一致，并且two方法输出的也是一致的。另一种同步的机制是在共享变量之前加上volatile：12345678910class Test &#123; static volatile int i = 0, j = 0; static void one() &#123; i++; j++; &#125; static void two() &#123; System.out.println(\"i=\" + i + \" j=\" + j); &#125; &#125;one方法和two方法还会并发的去执行，但是加上volatile可以将共享变量i和j的改变直接响应到主内存中，这样保证了主内存中i和j的值一致性，然而在执行two方法时，在two方法获取到i的值和获取到j的值中间的这段时间，one方法也许被执行了好多次，导致j的值会大于i的值。所以volatile可以保证内存可见性，不能保证并发有序性。​ 没有明白JLS中为什么使用两个变量来阐述volatile的工作原理，这样不是很好理解。volatile是一种弱的同步手段，相对于synchronized来说，某些情况下使用，可能效率更高，因为它不是阻塞的，尤其是读操作时，加与不加貌似没有影响，处理写操作的时候，可能消耗的性能更多些。但是volatile和synchronized性能的比较，我也说不太准，多线程本身就是比较玄的东西，依赖于CPU时间分片的调度，JVM更玄，还没有研究过虚拟机，从顶层往底层看往往是比较难看透的。在JDK5.0之前，如果没有参透volatile的使用场景，还是不要使用了，尽量用synchronized来处理同步问题，线程阻塞这玩意简单粗暴。另外volatile和final不能同时修饰一个字段，可以想想为什么。","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"}]},{"title":"java中实现同步的两种方式:syschronized和lock的区别和联系","slug":"java2017-03-12-2","date":"2017-03-12T22:12:27.000Z","updated":"2018-05-31T10:24:00.858Z","comments":true,"path":"posts/9a8ecd5e.html","link":"","permalink":"http://blog.liurenjie.top/posts/9a8ecd5e.html","excerpt":"Lock是java.util.concurrent.locks包下的接口，Lock 实现提供了比使用synchronized 方法和语句可获得的更广泛的锁定操作，它能以更优雅的方式处理线程同步问题，我们拿Java线程(二)中的一个例子简单的实现一下和sychronized一样的效果，代码如下：","text":"Lock是java.util.concurrent.locks包下的接口，Lock 实现提供了比使用synchronized 方法和语句可获得的更广泛的锁定操作，它能以更优雅的方式处理线程同步问题，我们拿Java线程(二)中的一个例子简单的实现一下和sychronized一样的效果，代码如下：1234567891011121314151617181920212223242526272829public class LockTest &#123; public static void main(String[] args) &#123; final Outputter1 output = new Outputter1(); new Thread() &#123; public void run() &#123; output.output(\"zhangsan\"); &#125;; &#125;.start(); new Thread() &#123; public void run() &#123; output.output(\"lisi\"); &#125;; &#125;.start(); &#125; &#125; class Outputter1 &#123; private Lock lock = new ReentrantLock();// 锁对象 public void output(String name) &#123; // TODO 线程输出方法 lock.lock();// 得到锁 try &#123; for(int i = 0; i &lt; name.length(); i++) &#123; System.out.print(name.charAt(i)); &#125; &#125; finally &#123; lock.unlock();// 释放锁 &#125; &#125; &#125;这样就实现了和sychronized一样的同步效果，需要注意的是，用sychronized修饰的方法或者语句块在代码执行完之后锁自动释放，而用Lock需要我们手动释放锁，所以为了保证锁最终被释放(发生异常情况)，要把互斥区放在try内，释放锁放在finally内。​ 如果说这就是Lock，那么它不能成为同步问题更完美的处理方式，下面要介绍的是读写锁(ReadWriteLock)，我们会有一种需求，在对数据进行读写的时候，为了保证数据的一致性和完整性，需要读和写是互斥的，写和写是互斥的，但是读和读是不需要互斥的，这样读和读不互斥性能更高些，来看一下不考虑互斥情况的代码原型：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; final Data data = new Data(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(new Runnable() &#123; public void run() &#123; for (int j = 0; j &lt; 5; j++) &#123; data.set(new Random().nextInt(30)); &#125; &#125; &#125;).start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; new Thread(new Runnable() &#123; public void run() &#123; for (int j = 0; j &lt; 5; j++) &#123; data.get(); &#125; &#125; &#125;).start(); &#125; &#125; &#125; class Data &#123; private int data;// 共享数据 public void set(int data) &#123; System.out.println(Thread.currentThread().getName() + \"准备写入数据\"); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.data = data; System.out.println(Thread.currentThread().getName() + \"写入\" + this.data); &#125; public void get() &#123; System.out.println(Thread.currentThread().getName() + \"准备读取数据\"); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"读取\" + this.data); &#125; &#125;部分输出结果：12345678910Thread-1准备写入数据 Thread-3准备读取数据 Thread-2准备写入数据 Thread-0准备写入数据 Thread-4准备读取数据 Thread-5准备读取数据 Thread-2写入12 Thread-4读取12 Thread-5读取5 Thread-1写入12我们要实现写入和写入互斥，读取和写入互斥，读取和读取互斥，在set和get方法加入sychronized修饰符：12public synchronized void set(int data) &#123;...&#125; public synchronized void get() &#123;...&#125;部分输出结果：12345678910Thread-0准备写入数据 Thread-0写入9 Thread-5准备读取数据 Thread-5读取9 Thread-5准备读取数据 Thread-5读取9 Thread-5准备读取数据 Thread-5读取9 Thread-5准备读取数据 Thread-5读取9我们发现，虽然写入和写入互斥了，读取和写入也互斥了，但是读取和读取之间也互斥了，不能并发执行，效率较低，用读写锁实现代码如下：123456789101112131415161718192021222324252627282930313233class Data &#123; private int data;// 共享数据 private ReadWriteLock rwl = new ReentrantReadWriteLock(); public void set(int data) &#123; rwl.writeLock().lock();// 取到写锁 try &#123; System.out.println(Thread.currentThread().getName() + \"准备写入数据\"); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.data = data; System.out.println(Thread.currentThread().getName() + \"写入\" + this.data); &#125; finally &#123; rwl.writeLock().unlock();// 释放写锁 &#125; &#125; public void get() &#123; rwl.readLock().lock();// 取到读锁 try &#123; System.out.println(Thread.currentThread().getName() + \"准备读取数据\"); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"读取\" + this.data); &#125; finally &#123; rwl.readLock().unlock();// 释放读锁 &#125; &#125; &#125;部分输出结果：12345678910111213Thread-4准备读取数据 Thread-3准备读取数据 Thread-5准备读取数据 Thread-5读取18 Thread-4读取18 Thread-3读取18 Thread-2准备写入数据 Thread-2写入6 Thread-2准备写入数据 Thread-2写入10 Thread-1准备写入数据 Thread-1写入22 Thread-5准备读取数据从结果可以看出实现了我们的需求，这只是锁的基本用法，锁的机制还需要继续深入学习。当一个线程进入了一个对象是的synchronized方法，那么其它线程还能掉否调用此对象的其它方法？这个问题需要分几种情况进行讨论。查看其它方法是否使用了同步关键字(synchronized)修饰，如果没有的话就可以调用相关的方法。在当前synchronized方法中是否调用了wait方法，如果调用了，则对应的锁已经释放，可以访问了。如果其它方法也使用synchronized修饰，并且当前同步方法中没有调用wait方法的话，这样是不允许访问的。如果其它方法是静态方法的话，由于静态方法和对象是扯不上什么关系，对于静态同步方法而言，其对应的同步监视器为当前类的字节码所以肯定可以访问的了。","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"}]},{"title":"几种常用加密算法比较","slug":"encrypt2017-03-12-1","date":"2017-03-12T21:30:45.000Z","updated":"2018-05-31T10:24:00.882Z","comments":true,"path":"posts/64baa540.html","link":"","permalink":"http://blog.liurenjie.top/posts/64baa540.html","excerpt":"由于计算机软件的非法复制，通信的泄密、数据安全受到威胁，解密及盗版问题日益严重，甚至引发国际争端，所以在信息安全技术中，加密技术占有不可替代的位置，因此对信息加密技术和加密手段的研究与开发，受到各国计算机界的重视，发展日新月异。现在我们就几种常用的加密算法给大家比较一下。几种常用加密算法比较","text":"由于计算机软件的非法复制，通信的泄密、数据安全受到威胁，解密及盗版问题日益严重，甚至引发国际争端，所以在信息安全技术中，加密技术占有不可替代的位置，因此对信息加密技术和加密手段的研究与开发，受到各国计算机界的重视，发展日新月异。现在我们就几种常用的加密算法给大家比较一下。几种常用加密算法比较DES加密算法DES加密算法是一种分组密码，以64位为分组对数据加密，它的密钥长度是56位，加密解密用同一算法。DES加密算法是对密钥进行保密，而公开算法，包括加密和解密算法。这样，只有掌握了和发送方相同密钥的人才能解读由DES加密算法加密的密文数据。因此，破译DES加密算法实际上就是搜索密钥的编码。对于56位长度的密钥来说，如果用穷举法来进行搜索的话，其运算次数为256。随着计算机系统能力的不断发展，DES的安全性比它刚出现时会弱得多，然而从非关键性质的实际出发，仍可以认为它是足够的。不过，DES现在仅用于旧系统的鉴定，而更多地选择新的加密标准。AES加密算法AES加密算法是密码学中的高级加密标准，该加密算法采用对称分组密码体制，密钥长度的最少支持为128、192、256，分组长度128位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的区块加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。AES加密算法被设计为支持128／192／256位（/32=nb)数据块大小（即分组长度）；支持128／192／256位（/32=nk)密码长度，，在10进制里，对应34×1038、62×1057、1.1×1077个密钥。RSA加密算法RSA加密算法是目前最有影响力的公钥加密算法，并且被普遍认为是目前最优秀的公钥方案之一。RSA是第一个能同时用于加密和数宇签名的算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。RSA加密算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。Base64加密算法Base64加密算法是网络上最常见的用于传输8bit字节代码的编码方式之一，Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在JAVAPERSISTENCE系统HIBEMATE中，采用了Base64来将一个较长的唯一标识符编码为一个字符串，用作HTTP表单和HTTPGETURL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。MD5加密算法MD5为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。对MD5加密算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成—个128位散列值。MD5被广泛用于各种软件的密码认证和钥匙识别上。MD5用的是哈希函数，它的典型应用是对一段信息产生信息摘要，以防止被篡改。MD5的典型应用是对一段Message产生fingerprin指纹，以防止被“篡改”。如果再有—个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。MD5还广泛用于操作系统的登陆认证上，如UNIX、各类BSD系统登录密码、数字签名等诸多方。SHA1加密算法SHA1是和MD5一样流行的消息摘要算法。SHA加密算法模仿MD4加密算法。SHA1设计为和数字签名算法（ＤＳＡ）一起使用。SHA1主要适用于数字签名标准里面定义的数字签名算法。对于长度小于2“64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。SHA1不可以从消息摘要中复原信息，而两个不同的消息不会产生同样的消息摘要。这样，SHA1就可以验证数据的完整性，所以说SHA1是为了保证文件完整性的技术。SHA1加密算法可以采用不超过264位的数据输入，并产生一个160位的摘要。输入被划分为512位的块，并单独处理。160位缓冲器用来保存散列函数的中间和最后结果。缓冲器可以由5个32位寄存器（A、B、C、D和E）来表示。SHA1是一种比MD5的安全性强的算法，理论上，凡是采取“消息摘要”方式的数字验证算法都是有“碰撞”的——也就是两个不同的东西算出的消息摘要相同，互通作弊图就是如此。但是安全性高的算法要找到指定数据的“碰撞”很困难，而利用公式来计算“碰撞”就更困难一目前为止通用安全算法中仅有MD5被破解。加密算法是密码技术的核心，以上这些加密算法是常用的加密算法，而这些算法有些已经遭到破译，有些安全度不高，有些强度不明，有些待进—步分析，有些需要深入研究，而神秘的加密算法世界，又会有新的成员加入，期待更安全的算法诞生。小知识之加密算法:数据加密的基本过程就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为“密文”，使其只能在输入相应的密钥之后才能显示出本来内容，通过这样的途径来达到保护数据不被非法人窃取、阅读的目的。 该过程的逆过程为解密，即将该编码信息转化为其原来数据的过程。对称加密算法(加解密密钥相同)名称密钥长度运算速度安全性资源消耗DES56位较快低中3DES112位或168位慢中高AES128、192、256位快高低非对称算法(加密密钥和解密密钥不同)名称成熟度安全性(取决于密钥长度)运算速度资源消耗RSA高高慢高DSA高高慢只能用于数字签名ECC低高快低(计算量小,存储空间占用小,带宽要求低)散列算法比较名称安全性速度SHA-1高慢MD5中快对称与非对称算法比较名称密钥管理安全性速度对称算法比较难,不适合互联网,一般用于内部系统中快好几个数量级(软件加解密速度至少快100倍,每秒可以加解密数M比特数据),适合大数据量的加解密处理非对称算法密钥容易管理高慢,适合小数据量加解密或数据签名算法选择(从性能和安全性综合)对称加密: AES(128位),非对称加密: ECC(160位)或RSA(1024),消息摘要: MD5数字签名:DSA","categories":[{"name":"加密","slug":"加密","permalink":"http://blog.liurenjie.top/categories/加密/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://blog.liurenjie.top/tags/加密/"}]},{"title":"Maven私服搭建问题总结","slug":"maven2017-03-10-2","date":"2017-03-10T23:37:10.000Z","updated":"2018-05-31T10:24:00.867Z","comments":true,"path":"posts/7e02aa5c.html","link":"","permalink":"http://blog.liurenjie.top/posts/7e02aa5c.html","excerpt":"发现maven不能从私服下载jar包。打开私服发现还需要配置一下东西。问题1： 解决central runting 状态不成功的方法repositories-&gt;central-&gt;routing ,如果状态不是成功的话，请根据一下步骤","text":"发现maven不能从私服下载jar包。打开私服发现还需要配置一下东西。问题1： 解决central runting 状态不成功的方法repositories-&gt;central-&gt;routing ,如果状态不是成功的话，请根据一下步骤 远程仓库地址：https://repo1.maven.org/maven2/这改完之后 保存 保存的同时请查看日志 左边栏 admin 里有logging-》log 如果发现这条异常：Remote strategy prefix-file on M2Repository(id=central) detected invalid input, results discarded: Prefix file size exceeds maximum allowed size (100000), refusing to load it这个时候 找到 nexus.properties 文件,这个文件在conf里面，我用的centos其他的系统去找找吧， 添加这：1org.sonatype.nexus.proxy.maven.routing.Config.prefixFileMaxSize = 500000这个时候再次点击保存，就显示没问题了 刷新一下回到第一步 也显示正常了。继续： 我的vps个人配置有点问题，在centos搭建配置小了好像不行我的 ram 512 swap 64 暂停了 。尴尬","categories":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/tags/maven/"},{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/tags/linux/"}]},{"title":"如何在centos上搭建自己maven仓库","slug":"maven2017-03-10-1","date":"2017-03-10T17:56:00.000Z","updated":"2018-05-31T10:24:00.891Z","comments":true,"path":"posts/a99ba9a7.html","link":"","permalink":"http://blog.liurenjie.top/posts/a99ba9a7.html","excerpt":"注：Nexus依赖JDK（nexus-2.11.*需要JDK1.7版本及以上）一。安装JDK步骤：第一步：下载 jdk-7u55-linux-i586.tar.gz （如果有网可以使用wget http://Oracle官网的下载地址）第二步：上传压缩包到linux系统。第三步：解压缩（将源文件压缩包解压至/usr/local下的jdk文件夹）。12mkdir -p /usr/local/jdktar -zxvf jdk-7u55-linux-i586.tar.gz -C /usr/local/jdk","text":"注：Nexus依赖JDK（nexus-2.11.*需要JDK1.7版本及以上）一。安装JDK步骤：第一步：下载 jdk-7u55-linux-i586.tar.gz （如果有网可以使用wget http://Oracle官网的下载地址）第二步：上传压缩包到linux系统。第三步：解压缩（将源文件压缩包解压至/usr/local下的jdk文件夹）。12mkdir -p /usr/local/jdktar -zxvf jdk-7u55-linux-i586.tar.gz -C /usr/local/jdk 使用java -version 查看是否安装成功！第四步：配置环境变量（vi编辑器使用:按i进入编辑模式，修改完成后按ESC键进入命令模式输入:wq命令保存并退出:q!强制退出）。vi /etc/profile 修改/etc/profile，在文件中添加如下内容：123456#set java environmentJAVA_HOME=/usr/local/jdk/jdk1.7.0_55JRE_HOME=/usr/local/jdk/jdk1.7.0_55/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH如下图第五步：source /etc/profile或者重启。source /etc/profile二。安装Nexus步骤：第一步：Nexus官网下载地址：http://www.sonatype.org/nexus/go/使用wget命令下载 wget 想要下载nexus版本的地址1wget https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.11.2-03-bundle.tar.gz第二步：解压123456[root@localhost nexus]# mkdir /usr/local/nexus[root@localhost nexus]# tar -zxvf nexus-2.11.2-03-bundle.tar.gz -C /usr/local/nexus/[root@localhost nexus]# cd /usr/local/nexus[root@localhost nexus]# lsnexus-2.11.2-03 sonatype-work(一个 nexus 服务，一个私有库目录)第三步：编辑 Nexus 的 nexus.properties 文件,配置端口和 work 目录信息（保留默认）123456[root@localhost nexus]# cd nexus-2.11.2-03[root@localhost nexus-2.11.2-03]# lsbin conf lib LICENSE.txt logs nexus NOTICE.txt tmp查看目录结构，jetty 运行[root@localhost nexus-2.11.2-03]# cd conf[root@localhost conf]# vi nexus.properties12345678# Jetty sectionapplication-port=8081application-host=0.0.0.0nexus-webapp=$&#123;bundleBasedir&#125;/nexusnexus-webapp-context-path=/nexus# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexusruntime=$&#123;bundleBasedir&#125;/nexus/WEB-INF如下图第四步：编辑 nexus 脚本, 配置 RUN_AS_USER 参数12345678[root@localhost conf]# vi /usr/nexus/nexus-2.11.2-03/bin/nexusNEXUS_HOME=\"..\"改为（不修改默认也可以）：NEXUS_HOME=\"nexus安装目录\"#RUN_AS_USER=改为：RUN_AS_USER=root第五步：防火墙中打开 8081 端口 [etc目录通常放一些零散的配置文件]123[root@localhost conf]# vi /etc/sysconfig/iptables#添加：-A INPUT -m state --state NEW -m tcp -p tcp --dport 8081 -j ACCEPT保存后重启防火墙（即使防火墙开着也可以访问，作为服务器安全第一）[root@localhost conf]# service iptables restart第六步：启动 nexus [nexus的bin目录下的可以执行文件可以进入bin查看]123456[root@localhost conf]# /usr/nexus/nexus-2.11.2-03/bin/nexus start****************************************WARNING - NOT RECOMMENDED TO RUN AS ROOT****************************************Starting Nexus OSS...Started Nexus OSS.浏览器输入地址 http://192.168.174.128:8081/nexus登录默认用户名 admin默认密码 admin123到此，Nexus 已安装完成。Nexus的访问权限模型Nexus是基于权限做访问控制的，服务器的每一个资源都有对应的权限来控制，因此用户执行特定的操作时就必须拥有必要的权限。管理员必须以角色的方式将权限赋予Nexus用户。用户可以被赋予一个或者多个角色，角色可以包含一个或多个权限，角色还可以包含一个或者多个其他角色。Nexus上预定义了三个用户，用admin登录后，单击页面左边的User链接，看到如下图列表：admin：该用户拥有Nexus的全部权限，默认密码为admin123。deployment：该用户能够访问Nexus，浏览仓库内容、搜索、上传部署构件，但是不能对Nexus进行任何配置，默认密码为deployment123。anonymous：该用户对应了所有未登录的匿名用户，它们可以浏览仓库并进行搜索。添加新用户并授予登录访问权限添加第三方jar默认情况下Nexus为我们创建了以下主要的Repository：Public Repositories，这是一个Repository Group，该Repository Group包含了多个Repository，其中包含了Releases、Snapshots、ThirdParty和Central。3rd party，该Repository即是存放你公司所购买的第三方软件库的地方，它是一个由Nexus自己维护的一个Repository。Apache Snapshots，看名字你就应该知道这是个什么样的Repository，这是一个代理Repository，即最终的依赖还是得在Apache官网上去下载，然后缓存在Nexus中。Central，这就是代理Maven Central Repository的Repository。Releases，你自己的项目要发布时，就应该发布在这个Repository，他也是Nexus自己维护的Repository，而不是代理。Snapshots，你自己项目Snapshot的Repository。使用3rd party上传第三方jar包在Repository列表中，选中 3rd party，选中artifact upload，选择GAV Defini3ion: GAV Parameters，Auto Guess 打钩。在下方输入JAR包对应的Group、Artifact、Version，Packaging选择JAR格式。点击select Artifact(s) to upload 按钮，选择要上传的JAR包。如下图所示然后 OK上传成功!输入pinyin4j点击搜索如下图：Nexus安装与配置 http://www.linuxidc.com/Linux/2016-09/135084.htmMaven使用入门 http://www.linuxidc.com/Linux/2012-11/74354.htmUbuntu 下 搭建Nexus Maven私服中央仓库 http://www.linuxidc.com/Linux/2016-08/133936.htmLinux下使用Nexus搭建Maven私服详解 http://www.linuxidc.com/Linux/2016-08/134630.htmLinux下使用Nexus搭建Maven私服 http://www.linuxidc.com/Linux/2016-08/134617.htmLinux下安装配置Nexus http://www.linuxidc.com/Linux/2016-09/135083.htm本文永久更新链接地址：http://www.linuxidc.com/Linux/2016-11/136954.htmsettings.xml文件配置123456789101112131415161718192021222324252627282930&lt;servers&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;liuxxxx&lt;/username&gt; &lt;password&gt;xxxx&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;public&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;my maven&lt;/name&gt; &lt;url&gt;http://xx.xx.xxx.xxx:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;","categories":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://blog.liurenjie.top/tags/maven/"},{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/tags/linux/"},{"name":"jdk","slug":"jdk","permalink":"http://blog.liurenjie.top/tags/jdk/"}]},{"title":"一键安装ssr脚本","slug":"shadowsocks2017-02-10-1","date":"2017-02-10T15:01:05.000Z","updated":"2018-05-31T10:24:00.874Z","comments":true,"path":"posts/78468f49.html","link":"","permalink":"http://blog.liurenjie.top/posts/78468f49.html","excerpt":"本脚本适用环境： 系统支持：CentOS，Debian，Ubuntu内存要求：≥128M日期：2016 年 08 月 13 日","text":"本脚本适用环境： 系统支持：CentOS，Debian，Ubuntu内存要求：≥128M日期：2016 年 08 月 13 日关于本脚本：一键安装 ShadowsocksR 服务端。请下载与之配套的客户端程序来连接。（以下客户端只有 Windows 客户端和 Python 版客户端可以使用 SSR 新特性，其他原版客户端只能以兼容的方式连接 SSR 服务器）默认配置：服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）密码：自己设定（如不设定，默认为 teddysun.com）加密方式：自己设定（如不设定，默认为 aes-256-cfb）协议（Protocol）：自己设定（如不设定，默认为 origin）混淆（obfs）：自己设定（如不设定，默认为 plain）客户端下载：Windows / OS XLinuxAndroid / iOSOpenWRT使用方法：使用root用户登录，运行以下命令：123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log安装完成后，脚本提示如下：12345678910Congratulations, ShadowsocksR server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Protocol :your_protocolYour obfs :your_obfsYour Encryption Method:your_encryption_methodWelcome to visit:https://shadowsocks.be/9.htmlEnjoy it!卸载方法：使用 root 用户登录，运行以下命令：1./shadowsocksR.sh uninstall安装完成后即已后台启动 ShadowsocksR ，运行：1/etc/init.d/shadowsocks status可以查看 ShadowsocksR 进程是否已经启动。本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。使用命令：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks多用户配置示例:123456789101112131415161718192021&#123; \"server\":\"0.0.0.0\", \"server_ipv6\": \"[::]\", \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":&#123; \"8989\":\"password1\", \"8990\":\"password2\"， \"8991\":\"password3\" &#125;, \"timeout\":300, \"method\":\"aes-256-cfb\", \"protocol\": \"origin\", \"protocol_param\": \"\", \"obfs\": \"plain\", \"obfs_param\": \"\", \"redirect\": \"\", \"dns_ipv6\": false, \"fast_open\": false, \"workers\": 1&#125;如果你想修改配置文件，请参考：https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setup https://github.com/shadowsocksr-backup/shadowsocks-rss/blob/master/ssr.md https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/config.json更新日志：2018 年 02 月 07 日：1、修改：将默认端口从 8989 改为从 9000-19999 之间随机生成。2018 年 02 月 06 日：1、修改：ShadowsocksR 版为 ShadowsocksRR 最新版；2、新增：ShadowsocksR 版的协议（protocol）增加了 4 个，分别为：1234auth_chain_cauth_chain_dauth_chain_eauth_chain_f2017 年 12 月 29 日：1、升级：libsodium 到 1.0.16。2017 年 07 月 27 日：1、新增：可选协议（protocol）auth_chain_b 。使用该协议需更新到最新版（4.7.0）ShadowsocksR 版客户端；2、修改：更新 ShadowsocksR 源码下载地址。2017 年 07 月 22 日：1、新增：安装时可选 15 种加密方式的其中之一（none 是不加密）。如下所示：12345678910111213141516noneaes-256-cfbaes-192-cfbaes-128-cfbaes-256-cfb8aes-192-cfb8aes-128-cfb8aes-256-ctraes-192-ctraes-128-ctrchacha20-ietfchacha20salsa20xchacha20xsalsa20rc4-md52、新增：安装时可选 7 种协议（protocol）的其中之一。如下所示：12345678originverify_deflateauth_sha1_v4auth_sha1_v4_compatibleauth_aes128_md5auth_aes128_sha1auth_chain_aauth_chain_b3、新增：安装时可选 9 种混淆（obfs）的其中之一。如下所示：123456789plainhttp_simplehttp_simple_compatiblehttp_posthttp_post_compatibletls1.2_ticket_authtls1.2_ticket_auth_compatibletls1.2_ticket_fastauthtls1.2_ticket_fastauth_compatible2016 年 08 月 13 日：1、新增多用户配置示例。注意：如果你新增了端口，也要将该端口从防火墙（iptables 或 firewalld）中打开。2016 年 05 月 12 日：1、新增在 CentOS 下的防火墙规则设置。参考链接：https://github.com/breakwa11/shadowsocks-rss另增加：单人配置vi /etc/shadowsocks.json123456789101112131415161718&#123; \"server\":\"0.0.0.0\", \"server_ipv6\":\"::\", \"server_port\":your_port, \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"password\":\"your_pwd\", \"timeout\":120, \"method\":\"aes-256-cfb\", \"protocol\":\"origin\", //协议 \"protocol_param\":\"\", \"obfs\":\"http_simple\",//混淆模式 \"obfs_param\":\"\", \"redirect\":\"\", \"dns_ipv6\":false, \"fast_open\":false, \"workers\":1 &#125;","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.liurenjie.top/categories/shadowsocks/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.liurenjie.top/tags/shadowsocks/"},{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/tags/linux/"}]},{"title":"mysql 用户管理和权限设置","slug":"mysql2017-02-09-1","date":"2017-02-09T13:23:12.000Z","updated":"2018-05-31T07:28:34.685Z","comments":true,"path":"posts/7c96e91b.html","link":"","permalink":"http://blog.liurenjie.top/posts/7c96e91b.html","excerpt":"用户管理mysql&gt;use mysql;查看mysql&gt; select host,user,password from user ;创建mysql&gt; create user zx_root IDENTIFIED by &#39;xxxxx&#39;; //identified by 会将纯文本密码加密作为散列值存储修改mysql&gt;rename user feng to newuser；//mysql 5之后可以使用，之前需要使用update 更新user表删除","text":"用户管理mysql&gt;use mysql;查看mysql&gt; select host,user,password from user ;创建mysql&gt; create user zx_root IDENTIFIED by &#39;xxxxx&#39;; //identified by 会将纯文本密码加密作为散列值存储修改mysql&gt;rename user feng to newuser；//mysql 5之后可以使用，之前需要使用update 更新user表删除mysql&gt;drop user newuser; //mysql5之前删除用户时必须先使用revoke 删除用户权限，然后删除用户，mysql5之后drop 命令可以删除用户的同时删除用户的相关权限更改密码mysql&gt; set password for zx_root =password(&#39;xxxxxx&#39;);mysql&gt; update mysql.user set password=password(&#39;xxxx&#39;) where user=&#39;otheruser&#39;查看用户权限mysql&gt; show grants for zx_root;赋予权限mysql&gt; grant select on dmc_db.* to zx_root;回收权限mysql&gt; revoke select on dmc_db.* from zx_root; //如果权限不存在会报错上面的命令也可使用多个权限同时赋予和回收，权限之间使用逗号分隔mysql&gt; grant select，update，delete ，insert on dmc_db.* to zx_root;如果想立即看到结果使用flush privileges ;命令更新设置权限时必须给出一下信息要授予的权限被授予访问权限的数据库或表用户名grant和revoke可以在几个层次上控制访问权限整个服务器，使用 grant ALL 和revoke ALL整个数据库，使用on database.*特点表，使用on database.table特定的列特定的存储过程user表中host列的值的意义% 匹配所有主机localhost localhost不会被解析成IP地址，直接通过UNIXsocket连接127.0.0.1 会通过TCP/IP协议连接，并且只能在本机访问；::1 ::1就是兼容支持ipv6的，表示同ipv4的127.0.0.1grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。grant select on testdb.* to common_user@’%’grant insert on testdb.* to common_user@’%’grant update on testdb.* to common_user@’%’grant delete on testdb.* to common_user@’%’或者，用一条 MySQL 命令来替代：grant select, insert, update, delete on testdb.* to common_user@’%’`grant 数据库开发人员，创建表、索引、视图、存储过程、函数。。。等权限。grant 创建、修改、删除 MySQL 数据表结构权限。grant create on testdb.* to developer@’192.168.0.%’;grant alter on testdb.* to developer@’192.168.0.%’;grant drop on testdb.* to developer@’192.168.0.%’;grant 操作 MySQL 外键权限。grant references on testdb.* to developer@’192.168.0.%’;grant 操作 MySQL 临时表权限。grant create temporary tables on testdb.* to developer@’192.168.0.%’;grant 操作 MySQL 索引权限。grant index on testdb.* to developer@’192.168.0.%’;grant 操作 MySQL 视图、查看视图源代码 权限。grant create view on testdb.* to developer@’192.168.0.%’;grant show view on testdb.* to developer@’192.168.0.%’;grant 操作 MySQL 存储过程、函数 权限。grant create routine on testdb.* to developer@’192.168.0.%’; -- now, can show procedure statusgrant alter routine on testdb.* to developer@’192.168.0.%’; -- now, you can drop a proceduregrant execute on testdb.* to developer@’192.168.0.%’;grant 普通 DBA 管理某个 MySQL 数据库的权限。grant all privileges on testdb to dba@’localhost’其中，关键字 “privileges” 可以省略。grant 高级 DBA 管理 MySQL 中所有数据库的权限。grant all on *.* to dba@’localhost’MySQL grant 权限，分别可以作用在多个层次上。grant 作用在整个 MySQL 服务器上：grant select on *.* to dba@localhost; – dba 可以查询 MySQL 中所有数据库中的表。grant all on *.* to dba@localhost; – dba 可以管理 MySQL 中的所有数据库grant 作用在单个数据库上：grant select on testdb.* to dba@localhost; – dba 可以查询 testdb 中的表。grant 作用在单个数据表上：grant select, insert, update, delete on testdb.orders to dba@localhost;grant 作用在表中的列上：grant select(id, se, rank) on testdb.apache_log to dba@localhost;grant 作用在存储过程、函数上：grant execute on procedure testdb.pr_add to ’dba’@’localhost’grant execute on function testdb.fn_add to ’dba’@’localhost’注意：修改完权限以后 一定要刷新服务，或者重启服务，刷新服务用：FLUSH PRIVILEGES。权限表权限说明allalteralter routine使用alter procedure 和drop procedurecreatecreate routine使用create procedurecreate temporary tables使用create temporary tablecreate usercreate viewdeletedropexecute使用call和存储过程file使用select into outfile 和load data infilegrant option可以使用grant和revokeindex可以使用create index 和drop indexinsertlock tables锁表process使用show full processlistreload使用flushreplication client服务器位置访问replocation slave由复制从属使用selectshow databasesshow viewshutdown使用mysqladmin shutdown 来关闭mysqlsuperupdateusage无访问权限","categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"}]},{"title":"DOS/BAT批处理if exist else 语句的几种用法","slug":"dos2017-01-13-1","date":"2017-01-13T10:31:32.000Z","updated":"2018-05-31T07:05:03.885Z","comments":true,"path":"posts/472ddb62.html","link":"","permalink":"http://blog.liurenjie.top/posts/472ddb62.html","excerpt":"在DOS批处理命令中常常会通过if语句来进行判断来执行下面的命令， 那么批处理if语句怎么用呢，下面学无忧小编就来说说有关批处理if以及if exist else语句的相关内容。","text":"在DOS批处理命令中常常会通过if语句来进行判断来执行下面的命令， 那么批处理if语句怎么用呢，下面学无忧小编就来说说有关批处理if以及if exist else语句的相关内容。一、批处理if书写格式if 条件表达式 (语句1) else (语句2)，它的含义是：如果条件表达式成立，那么，就执行语句1，否则，将执行语句2。这个if else 这里必须在同一行二、四种批处理if的用法1、判断驱动器、文件或文件夹是否存在，用 if exist 语句例如：if exist c:\\xue51com.txt (echo c盘下有xue51com.txt存在) else (echo c盘下不存在xue51com.txt)2、判断某两个字符串是否相等，用 if “字符串1”==”字符串2” 语句例如：if &quot;xue&quot;==&quot;xyz&quot; (echo 字符串xue等于字符串xyz) else (echo 字符串xue不等于字符串xyz)，这个例子主要是检测字符串(注意，用if检测字符串是否相等的时候，后面用的不是“=”，而是“==”)3、判断某两个数值是否相等，用 if 数值1 equ 数值2 语句举例：if 1 equ 2 (echo 1等于2) else (echo 1不等于2)，这个例子功能是检测数值：（注意，批处理中大于符号不能用：“&gt;”,而用&quot;gtr&quot;，其它的也类似）比较运算符一览：EQU - 等于NEQ - 不等于LSS - 小于LEQ - 小于或等于GTR - 大于GEQ - 大于或等于4、判断某个变量是否已经被赋值，用 if defined str 语句举例：if defined str (echo 变量str已经被赋值，其值为%str%) else (echo 变量str的值为空)5、if结合errorlevel使用说明：环境变量errorlevel的初始值为0，当一些命令执行不成功，就会返回一个数值，如：1 ，2 等IF-ERRORLEVEL举例：123XCOPY F:\\test.bat D:\\IF ERRORLEVEL 1 ECHO 文件拷贝失败IF ERRORLEVEL 0 ECHO 成功拷贝文件如果文件拷贝成功，屏幕就会显示“成功拷贝文件”，否则就会显示“文件拷贝失败”IF ERRORLEVEL 是用来测试它的上一个DOS命令的返回值的，注意只是上一个命令的返回值，而且返回值必须依照从大到小次序顺序判断。因此下面的批处理文件是错误的：1234567@ECHO OFFXCOPY C:\\AUTOEXEC.BAT D:\\IF ERRORLEVEL 0 ECHO 成功拷贝文件IF ERRORLEVEL 1 ECHO 未找到拷贝文件IF ERRORLEVEL 2 ECHO 用户通过ctrl-c中止拷贝操作IF ERRORLEVEL 3 ECHO 预置错误阻止文件拷贝操作IF ERRORLEVEL 4 ECHO 拷贝过程中写盘错误无论拷贝是否成功，后面的：未找到拷贝文件用户通过ctrl-c中止拷贝操作预置错误阻止文件拷贝操作拷贝过程中写盘错误以上就是有关OS/BAT批处理if的几种用法，希望对你有所帮助。","categories":[{"name":"windows","slug":"windows","permalink":"http://blog.liurenjie.top/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://blog.liurenjie.top/tags/windows/"},{"name":"dos","slug":"dos","permalink":"http://blog.liurenjie.top/tags/dos/"},{"name":"bat","slug":"bat","permalink":"http://blog.liurenjie.top/tags/bat/"}]},{"title":"CentOS6.5安装与配置Mysql数据库","slug":"linux2017-01-11-5","date":"2017-01-11T16:32:00.000Z","updated":"2018-06-01T01:42:51.419Z","comments":true,"path":"posts/7034b073.html","link":"","permalink":"http://blog.liurenjie.top/posts/7034b073.html","excerpt":"一、mysql简介说到数据库，我们大多想到的是关系型数据库，比如mysql、oracle、sqlserver等等，这些数据库软件在windows上安装都非常的方便，在Linux上如果要安装数据库，咱不得不首先推荐的是mysql数据库了，而且Mysql数据库的第一个版本就是发行在Linux系统上的。MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL的SQL语言是用于访问数据库的最常用标准化语言。MySQL软件采用了双授权政策（本词条“授权政策”），它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。由于其社区版的性能卓越，搭配PHP和Apache可组成良好的开发环境。","text":"一、mysql简介说到数据库，我们大多想到的是关系型数据库，比如mysql、oracle、sqlserver等等，这些数据库软件在windows上安装都非常的方便，在Linux上如果要安装数据库，咱不得不首先推荐的是mysql数据库了，而且Mysql数据库的第一个版本就是发行在Linux系统上的。MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL的SQL语言是用于访问数据库的最常用标准化语言。MySQL软件采用了双授权政策（本词条“授权政策”），它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。由于其社区版的性能卓越，搭配PHP和Apache可组成良好的开发环境。在Linux上安装mysql数据库，我们可以去其官网上下载mysql数据库的rpm包，http://dev.mysql.com/downloads/mysql/5.6.html#downloads，大家可以根据自己的操作系统去下载对应的数据库文件，目前最新的版本是5.6.10了。在这里我是通过yum来进行mysql数据库的安装的，通过这种方式进行安装，可以将跟mysql相关的一些服务、jar包都给我们安装好，所以省去了很多不必要的麻烦！！！二、卸载掉原有mysql因为mysql数据库在Linux上实在是太流行了，所以目前下载的主流Linux系统版本基本上都集成了mysql数据库在里面，我们可以通过如下命令来查看我们的操作系统上是否已经安装了mysql数据库1[root@xiaoluo ~]# rpm -qa | grep mysql // 这个命令就会查看该操作系统上是否已经安装了mysql数据库有的话，我们就通过 rpm -e 命令 或者 rpm -e –nodeps 命令来卸载掉12[root@xiaoluo ~]# rpm -e mysql // 普通删除模式[root@xiaoluo ~]# rpm -e --nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除在删除完以后我们可以通过 rpm -qa | grep mysql 命令来查看mysql是否已经卸载成功！！三、通过yum来进行mysql的安装我是通过yum的方式来进行mysql的数据库安装，首先我们可以输入 yum list | grep mysql 命令来查看yum上提供的mysql数据库可下载的版本：1[root@xiaoluo ~]# yum list | grep mysql就可以得到yum服务器上mysql数据库的可下载版本信息：然后我们可以通过输入 yum install -y mysql-server mysql mysql-devel 命令将mysql mysql-server mysql-devel都安装好(注意:安装mysql时我们并不是安装了mysql客户端就相当于安装好了mysql数据库了，我们还需要安装mysql-server服务端才行)1[root@xiaoluo ~]# yum install -y mysql-server mysql mysql-deve在等待了一番时间后，yum会帮我们选择好安装mysql数据库所需要的软件以及其它附属的一些软件我们发现，通过yum方式安装mysql数据库省去了很多没必要的麻烦，当出现下面的结果时，就代表mysql数据库安装成功了此时我们可以通过如下命令，查看刚安装好的mysql-server的版本1[root@xiaoluo ~]# rpm -qi mysql-server我们安装的mysql-server并不是最新版本，如果你想尝试最新版本，那就去mysql官网下载rpm包安装就行了，至此我们的mysql数据库已经安装完成了。四、mysql数据库的初始化及相关配置我们在安装完mysql数据库以后，会发现会多出一个mysqld的服务，这个就是咱们的数据库服务，我们通过输入 service mysqld start 命令就可以启动我们的mysql服务。注意：如果我们是第一次启动mysql服务，mysql服务器首先会进行初始化的配置，如：1234567891011121314151617181920212223242526272829303132333435363738394041[root@xiaoluo ~]# service mysqld start初始化 MySQL 数据库： WARNING: The host 'xiaoluo' could not be looked up with resolveip.This probably means that your libc libraries are not 100 % compatiblewith this binary MySQL version. The MySQL daemon, mysqld, should worknormally with the exception that host name resolving will not work.This means that you should use IP addresses instead of hostnameswhen specifying MySQL privileges !Installing MySQL system tables...OKFilling help tables...OKTo start mysqld at boot time you have to copysupport-files/mysql.server to the right place for your systemPLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !To do so, start the server, then issue the following commands:/usr/bin/mysqladmin -u root password 'new-password'/usr/bin/mysqladmin -u root -h xiaoluo password 'new-password'Alternatively you can run:/usr/bin/mysql_secure_installationwhich will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers.See the manual for more instructions.You can start the MySQL daemon with:cd /usr ; /usr/bin/mysqld_safe &amp;You can test the MySQL daemon with mysql-test-run.plcd /usr/mysql-test ; perl mysql-test-run.plPlease report any problems with the /usr/bin/mysqlbug script! [确定]正在启动 mysqld： [确定]这时我们会看到第一次启动mysql服务器以后会提示非常多的信息，目的就是对mysql数据库进行初始化操作，当我们再次重新启动mysql服务时，就不会提示这么多信息了，如：123[root@xiaoluo ~]# service mysqld restart停止 mysqld： [确定]正在启动 mysqld： [确定]我们在使用mysql数据库时，都得首先启动mysqld服务，我们可以 通过 chkconfig --list | grep mysqld 命令来查看mysql服务是不是开机自动启动，如：12[root@xiaoluo ~]# chkconfig --list | grep mysqldmysqld 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭我们发现mysqld服务并没有开机自动启动，我们当然可以通过 chkconfig mysqld on 命令来将其设置成开机启动，这样就不用每次都去手动启动了123[root@xiaoluo ~]# chkconfig mysqld on[root@xiaoluo ~]# chkconfig --list | grep mysqlmysqld 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭mysql数据库安装完以后只会有一个root管理员账号，但是此时的root账号还并没有为其设置密码，在第一次启动mysql服务时，会进行数据库的一些初始化工作，在输出的一大串信息中，我们看到有这样一行信息 ：1/usr/bin/mysqladmin -u root password 'new-password' // 为root账号设置密码所以我们可以通过 该命令来给我们的root账号设置密码(注意：这个root账号是mysql的root账号，非Linux的root账号)1[root@xiaoluo ~]# mysqladmin -u root password 'root' // 通过该命令给root账号设置密码为 root此时我们就可以通过 mysql -u root -p 命令来登录我们的mysql数据库了五、mysql数据库的主要配置文件/etc/my.cnf 这是mysql的主配置文件我们可以查看一下这个文件的一些信息1234567891011121314[root@xiaoluo etc]# ls my.cnf my.cnf[root@xiaoluo etc]# cat my.cnf [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid/var/lib/mysql mysql数据库的数据库文件存放位置我们的mysql数据库的数据库文件通常是存放在了/ver/lib/mysql这个目录下123456789[root@xiaoluo ~]# cd /var/lib/mysql/[root@xiaoluo mysql]# ls -l总用量 20488-rw-rw----. 1 mysql mysql 10485760 4月 6 22:01 ibdata1-rw-rw----. 1 mysql mysql 5242880 4月 6 22:01 ib_logfile0-rw-rw----. 1 mysql mysql 5242880 4月 6 21:59 ib_logfile1drwx------. 2 mysql mysql 4096 4月 6 21:59 mysql // 这两个是mysql数据库安装时默认的两个数据库文件srwxrwxrwx. 1 mysql mysql 0 4月 6 22:01 mysql.sockdrwx------. 2 mysql mysql 4096 4月 6 21:59 test // 这两个是mysql数据库安装时默认的两个数据库文件我们可以自己创建一个数据库，来验证一下该数据库文件的存放位置12345678910111213141516//创建一个我们自己的数据库：mysql&gt; create database xiaoluo;Query OK, 1 row affected (0.00 sec)[root@xiaoluo mysql]# ls -l总用量 20492-rw-rw----. 1 mysql mysql 10485760 4月 6 22:01 ibdata1-rw-rw----. 1 mysql mysql 5242880 4月 6 22:01 ib_logfile0-rw-rw----. 1 mysql mysql 5242880 4月 6 21:59 ib_logfile1drwx------. 2 mysql mysql 4096 4月 6 21:59 mysqlsrwxrwxrwx. 1 mysql mysql 0 4月 6 22:01 mysql.sockdrwx------. 2 mysql mysql 4096 4月 6 21:59 testdrwx------. 2 mysql mysql 4096 4月 6 22:15 xiaoluo // 这个就是我们刚自己创建的xiaoluo数据库[root@xiaoluo mysql]# cd xiaoluo/[root@xiaoluo xiaoluo]# lsdb.opt/var/log mysql数据库的日志输出存放位置我们的mysql数据库的一些日志输出存放位置都是在/var/log这个目录下1234567891011121314151617[root@xiaoluo xiaoluo]# cd [root@xiaoluo ~]# cd /var/log[root@xiaoluo log]# lsamanda cron maillog-20130331 spice-vdagent.loganaconda.ifcfg.log cron-20130331 mcelog spooleranaconda.log cups messages spooler-20130331anaconda.program.log dirsrv messages-20130331 sssdanaconda.storage.log dmesg mysqld.log tallyloganaconda.syslog dmesg.old ntpstats tomcat6anaconda.xlog dracut.log piranha wpa_supplicant.loganaconda.yum.log gdm pm-powersave.log wtmpaudit httpd ppp Xorg.0.logboot.log ibacm.log prelink Xorg.0.log.oldbtmp lastlog sa Xorg.1.logbtmp-20130401 libvirt samba Xorg.2.logcluster luci secure Xorg.9.logConsoleKit maillog secure-20130331 yum.log其中mysqld.log 这个文件就是我们存放我们跟mysql数据库进行操作而产生的一些日志信息，通过查看该日志文件，我们可以从中获得很多信息因为我们的mysql数据库是可以通过网络访问的，并不是一个单机版数据库，其中使用的协议是 tcp/ip 协议，我们都知道mysql数据库绑定的端口号是 3306 ，所以我们可以通过 netstat -anp 命令来查看一下，Linux系统是否在监听 3306 这个端口号：结果如上所示，Linux系统监听的3306端口号就是我们的mysql数据库！！！！","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"},{"name":"centos6","slug":"centos6","permalink":"http://blog.liurenjie.top/tags/centos6/"}]},{"title":"在 CentOS7 上安装 Tomcat9","slug":"linux2017-01-11-4","date":"2017-01-11T16:04:02.000Z","updated":"2018-06-01T01:42:51.414Z","comments":true,"path":"posts/375984d0.html","link":"","permalink":"http://blog.liurenjie.top/posts/375984d0.html","excerpt":"通过 SecureCRT 连接到阿里云 CentOS7 服务器；进入到目录 /usr/local/ 中：cd /usr/local/创建目录 /usr/local/tools，如果有则忽略：mkdir -p tools创建 /usr/local/tomcat 目录，如果已存在则忽略：mkdir -p tomcat","text":"通过 SecureCRT 连接到阿里云 CentOS7 服务器；进入到目录 /usr/local/ 中：cd /usr/local/创建目录 /usr/local/tools，如果有则忽略：mkdir -p tools创建 /usr/local/tomcat 目录，如果已存在则忽略：mkdir -p tomcat进入到目录 /usr/local/tools 中：cd tools/下载 apache-tomcat-9.0.0.M4.tar.gz 文件：wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.0.M4/bin/apache-tomcat-9.0.0.M4.tar.gz解压缩 apache-tomcat-9.0.0.M4.tar.gz：tar -zxvf apache-tomcat-9.0.0.M4.tar.gz将通过解压得到的 apache-tomcat-9.0.0.M4 文件复制到 /usr/local/tomcat 目录中：mv apache-tomcat-9.0.0.M4 ../tomcat/打开文件 /etc 目录下的 profile 文件：vim /etc/profile将如下代码追加到 profile 文件末尾：1234567891011# idea - tomcat9 config start - 2016-05-01 CATALINA_HOME=/usr/local/tomcat/apache-tomcat-9.0.0.M4 CATALINA_BASE=/usr/local/tomcat/apache-tomcat-9.0.0.M4 PATH=PATH:CATALINA_BASE/bin export PATH CATALINA_BASE # idea - tomcat9 config end - 2016-05-01保持并推出:wq!修改 tomcat 的端口号和字符编码：进入到 /usr/local/tomcat/apache-tomcat-9.0.0.M4/conf 目录中：cd ../tomcat/apache-tomcat-9.0.0.M4/conf打开 tomcat 服务的配置文件 server.xml：vi server.xml找到如下代码：&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;将其中的 8080 改成 HTTP 协议的默认端口 80，改后的代码如下：&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;增加 manager-gui 图形化管理界面的访问权限（不需要的话，此步骤可忽略）：打开 tomcat 的用户配置文件 tomcat-users.xml：vi tomcat-users.xml在 标签前加入如下代码：&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui&quot;/&gt;这里设置的 username 和 password 都是 tomcat，角色为 manager-gui；键入 Esc 并输入“:wq!”保持并退出；进入到 /usr/local/tomcat/apache-tomcat-9.0.0.M4/bin 目录中：cd ../bin/打开 vi catalina.sh 文件：在 # OS specific support. 前面加入如下代码：12JAVA_HOME=/usr/local/jdk/jdk1.8.0_91JRE_HOME=$JAVA_HOME/jre键入 Esc 并输入“:wq!”保持并退出；启动 tomcat 服务：./startup.sh打印如下信息则表明启动 Tomcat 服务成功：123456Using CATALINA_BASE: /usr/local/tomcat/apache-tomcat-9.0.0.M4Using CATALINA_HOME: /usr/local/tomcat/apache-tomcat-9.0.0.M4Using CATALINA_TMPDIR: /usr/local/tomcat/apache-tomcat-9.0.0.M4/tempUsing JRE_HOME: /usr/local/jdk/jdk1.8.0_91/jreUsing CLASSPATH: /usr/local/tomcat/apache-tomcat-9.0.0.M4/bin/bootstrap.jar:/usr/local/tomcat/apache-tomcat-9.0.0.M4/bin/tomcat-juli.jarTomcat started.打开浏览器输入 IP 地址看看吧！如果出现了我们的可爱的“小黄猫”则表明我们的 Tomcat 已提供服务啦！关闭 tomcat 服务：./shutdown.sh打印如下信息则表明关闭 Tomcat 服务成功：12345Using CATALINA_BASE: /usr/local/tomcat/apache-tomcat-9.0.0.M4Using CATALINA_HOME: /usr/local/tomcat/apache-tomcat-9.0.0.M4Using CATALINA_TMPDIR: /usr/local/tomcat/apache-tomcat-9.0.0.M4/tempUsing JRE_HOME: /usr/local/jdk/jdk1.8.0_91/jreUsing CLASSPATH: /usr/local/tomcat/apache-tomcat-9.0.0.M4/bin/bootstrap.jar:/usr/local/tomcat/apache-tomcat-9.0.0.M4/bin/tomcat-juli.jar注意：不可连续执行多次 ./shutdown.sh 命令，多次后报如下错误：123456789101112131415161718SEVERE: Catalina.stop: java.net.ConnectException: Connection refused at java.net.PlainSocketImpl.socketConnect(Native Method) at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) at java.net.Socket.connect(Socket.java:589) at java.net.Socket.connect(Socket.java:538) at java.net.Socket.&lt;init&gt;(Socket.java:434) at java.net.Socket.&lt;init&gt;(Socket.java:211) at org.apache.catalina.startup.Catalina.stopServer(Catalina.java:476) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.catalina.startup.Bootstrap.stopServer(Bootstrap.java:408) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:497)将 tomcat9 加入到系统服务列表中：进入到 /etc/init.d 目录中：cd /etc/init.d创建 tomcat9 服务配置文件：vi tomcat9将如下代码加入写入到 tomcat9 配置文件中：12345678910111213141516171819202122232425# idea - tomcat config start - 2016-05-01#!/bin/bash# description: Tomcat Start Stop Restart# processname: tomcat# chkconfig: 2345 20 80JAVA_HOME=/usr/local/jdk/jdk1.8.0_91/export JAVA_HOMEPATH=JAVA_HOME/bin:PATHexport PATHCATALINA_HOME=/usr/local/tomcat/apache-tomcat-9.0.0.M4/case $1 in start) sh $CATALINA_HOME/bin/startup.sh;; stop) sh $CATALINA_HOME/bin/shutdown.sh;; restart) sh $CATALINA_HOME/bin/shutdown.sh sh $CATALINA_HOME/bin/startup.sh;; esac exit 0 #chmod 755 tomcat #chkconfig --add tomcat #chkconfig --level 2345 tomcat on #chkconfig --list tomcat # idea - tomcat config end - 2016-05-01键入 Esc 并输入“:wq!”保持并退出；其中的注意点是将 JAVA_HOME 和 CATALINA_HOME 变量设置成与我们当前配置相一致的路径；为 tomcat9 分配可执行权限：chmod +x tomcat9将 tomcat9 纳入到系统的服务列表中，即添加 tomcat9 为系统服务：chkconfig --add tomcat9查看当前系统服务都有哪些：chkconfig --list也可以查看指定的系统服务，如这里我们指定 tomcat9 这个服务：chkconfig --list tomcat9打印如下信息：tomcat9 0:off 1:off 2:on 3:on 4:on 5:on 6:off则表明已将 tomcat9 设置为系统服务，2、3、4、5 都为 on 表示可随系统自动启动；我们可以在任意目录下执行关闭、启动、重启 Tomcat9 服务啦：关闭 tomcat9 服务：service tomcat9 stop启动 tomcat9 服务：service tomcat9 start重启 tomcat9 服务：service tomcat9 restart后记：linux 系统中的 /etc 目录表示“设备”，意为与硬件设备相关的信息；/etc/init.d 目录下的文件表示当前设备的初始化配置信息；命令 chkconfig 表示添加（–add）、删除（–del）、查看（–list）系统服务；","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://blog.liurenjie.top/tags/centos7/"},{"name":"centos6","slug":"centos6","permalink":"http://blog.liurenjie.top/tags/centos6/"},{"name":"tomcat","slug":"tomcat","permalink":"http://blog.liurenjie.top/tags/tomcat/"}]},{"title":"centos手动安装jdk","slug":"linux2017-01-11-3","date":"2017-01-11T15:54:40.000Z","updated":"2018-06-01T01:42:51.408Z","comments":true,"path":"posts/c339e7f3.html","link":"","permalink":"http://blog.liurenjie.top/posts/c339e7f3.html","excerpt":"Linux版本：CentOS 6.5、Ubuntu 12.04.5JDK版本：JDK 1.7方法一：手动解压JDK的压缩包，然后设置环境变量在/usr/目录下创建java目录12[root@localhost ~]# mkdir/usr/java[root@localhost ~]# cd /usr/java下载，然后解压12[root@localhost java]# curl -O http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz [root@localhost java]# tar -zxvf jdk-7u79-linux-x64.tar.gz","text":"Linux版本：CentOS 6.5、Ubuntu 12.04.5JDK版本：JDK 1.7方法一：手动解压JDK的压缩包，然后设置环境变量在/usr/目录下创建java目录12[root@localhost ~]# mkdir/usr/java[root@localhost ~]# cd /usr/java下载，然后解压12[root@localhost java]# curl -O http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz [root@localhost java]# tar -zxvf jdk-7u79-linux-x64.tar.gz设置环境变量1[root@localhost java]# vi /etc/profile添加如下内容：123456#set java environmentJAVA_HOME=/usr/java/jdk1.7.0_79JRE_HOME=/usr/java/jdk1.7.0_79/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH让修改生效：1[root@localhost java]# source /etc/profile验证1234[root@localhost java]# java -versionjava version \"1.7.0_79\"Java(TM) SE Runtime Environment (build 1.7.0_79-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)方法二：用yum安装JDK(CentOS)查看yum库中都有哪些jdk版本12345678910111213141516171819[root@localhost ~]# yum search java|grep jdkldapjdk-javadoc.x86_64 : Javadoc for ldapjdkjava-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environmentjava-1.6.0-openjdk-demo.x86_64 : OpenJDK Demosjava-1.6.0-openjdk-devel.x86_64 : OpenJDK Development Environmentjava-1.6.0-openjdk-javadoc.x86_64 : OpenJDK API Documentationjava-1.6.0-openjdk-src.x86_64 : OpenJDK Source Bundlejava-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environmentjava-1.7.0-openjdk-demo.x86_64 : OpenJDK Demosjava-1.7.0-openjdk-devel.x86_64 : OpenJDK Development Environmentjava-1.7.0-openjdk-javadoc.noarch : OpenJDK API Documentationjava-1.7.0-openjdk-src.x86_64 : OpenJDK Source Bundlejava-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environmentjava-1.8.0-openjdk-demo.x86_64 : OpenJDK Demosjava-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environmentjava-1.8.0-openjdk-headless.x86_64 : OpenJDK Runtime Environmentjava-1.8.0-openjdk-javadoc.noarch : OpenJDK API Documentationjava-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundleldapjdk.x86_64 : The Mozilla LDAP Java SDK选择版本，进行安装我们这里安装1.7版本1[root@localhost ~]# yum install java-1.7.0-openjdk安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_64设置环境变量1root@localhost ~]# vi /etc/profile添加如下内容：123456#set java environmentJAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_64JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH让修改生效：1[root@localhost java]# source /etc/profile验证同上。因为采用yum安装jdk，系统考虑到多版本的问题，会用alternatives进行版本控制。开始，相应版本的jdk安装在/usr/lib/jvm/之后，会在alternatives中注册，在/etc/alternatives目录下会产生一些链接到/usr/lib/jvm/中刚安装好的jdk版本。在/usr/bin下面会有链接到/etc/alternatives的相应的文件。比如，/usr/bin下面会有一个链接文件java的映射关系如下：12/usr/bin/java-&gt;/etc/alternatives/java/etc/alternatives/java-&gt; /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java这样，java命令不用设置环境变量，就可以正常运行了。但如果对于tomcat或其他软件来说还是要设置环境变量。同样，如果安装新的版本jdk，就会重新链接到最新安装的jdk版本。当然，也可以使用alternatives修改所要使用的版本。具体方法可参照：《使用Linux的alternatives管理多版本的软件》方法三：用rpm安装JDK下载1[hadoop@localhost ~]$ curl -O http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.rpm使用rpm命令安装12345678910[root@localhost ~]# rpm -ivh jdk-7u79-linux-x64.rpmPreparing... ########################################### [100%] 1:jdk ###########################################[100%]Unpacking JAR files... rt.jar... jsse.jar... charsets.jar... tools.jar... localedata.jar... jfxrt.jar...设置环境变量1[root@localhost java]# vi /etc/profile添加如下内容：123456#set java environmentJAVA_HOME=/usr/java/jdk1.7.0_79JRE_HOME=/usr/java/jdk1.7.0_79/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH让修改生效：1[root@localhost java]# source /etc/profile验证1234[root@localhost java]# java -versionjava version \"1.7.0_79\"Java(TM) SE Runtime Environment (build 1.7.0_79-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)和yum安装类似，不用设置环境变量就可以，运行java命令。rpm安装方式默认会把jdk安装到/usr/java/jdk1.7.0_79，然后通过三层链接，链接到/usr/bin,具体链接如下：1234567891011121314[root@localhost ~]# cd /bin[root@localhost bin]# ll|grep javalrwxrwxrwx. 1 root root 25 Mar 28 11:24 jar -&gt;/usr/java/default/bin/jarlrwxrwxrwx. 1 root root 26 Mar 28 11:24 java -&gt; /usr/java/default/bin/javalrwxrwxrwx. 1 root root 27 Mar 28 11:24 javac -&gt;/usr/java/default/bin/javaclrwxrwxrwx. 1 root root 29 Mar 28 11:24 javadoc -&gt;/usr/java/default/bin/javadoclrwxrwxrwx. 1 root root 28 Mar 28 11:24 javaws -&gt;/usr/java/default/bin/javawslrwxrwxrwx. 1 root root 30 Mar 28 11:24 jcontrol -&gt;/usr/java/default/bin/jcontrol[root@localhost bin]# cd /usr/java/[root@localhost java]# lltotal 4lrwxrwxrwx. 1 root root 16 Mar 28 11:24 default-&gt; /usr/java/latestdrwxr-xr-x. 8 root root 4096 Mar 28 11:24 jdk1.7.0_79lrwxrwxrwx. 1 root root 21 Mar 28 11:24 latest -&gt; /usr/java/jdk1.7.0_79方法四：Ubuntu 上使用apt-get安装JDK查看apt库都有哪些jdk版本1234567891011121314151617181920212223root@Itble:~# apt-cache search java|grep jdkdefault-jdk - Standard Java or Java compatible Development Kitdefault-jdk-doc - Standard Java or Java compatible Development Kit (documentation)gcj-4.6-jdk - gcj and classpath development tools for Java(TM)gcj-jdk - gcj and classpath development tools for Java(TM)openjdk-6-dbg - Java runtime based on OpenJDK (debugging symbols)openjdk-6-demo - Java runtime based on OpenJDK (demos and examples)openjdk-6-doc - OpenJDK Development Kit (JDK) documentationopenjdk-6-jdk - OpenJDK Development Kit (JDK)openjdk-6-jre-lib - OpenJDK Java runtime (architecture independent libraries)openjdk-6-source - OpenJDK Development Kit (JDK) source filesopenjdk-7-dbg - Java runtime based on OpenJDK (debugging symbols)openjdk-7-demo - Java runtime based on OpenJDK (demos and examples)openjdk-7-doc - OpenJDK Development Kit (JDK) documentationopenjdk-7-jdk - OpenJDK Development Kit (JDK)openjdk-7-source - OpenJDK Development Kit (JDK) source filesuwsgi-plugin-jvm-openjdk-6 - Java plugin for uWSGI (OpenJDK 6)uwsgi-plugin-jwsgi-openjdk-6 - JWSGI plugin for uWSGI (OpenJDK 6)openjdk-6-jre - OpenJDK Java runtime, using Hotspot JITopenjdk-6-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)openjdk-7-jre - OpenJDK Java runtime, using Hotspot JITopenjdk-7-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)openjdk-7-jre-lib - OpenJDK Java runtime (architecture independent libraries)选择版本进行安装1root@Itble:~# apt-get install openjdk-7-jdk设置环境变量1root@Itble:~# vi /etc/profile添加如下内容：123456#set java environmentJAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-amd64JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH让修改生效：1root@Itble:~# source /etc/profile验证1234root@Itble:~# java -versionjava version \"1.7.0_79\"OpenJDK Runtime Environment (IcedTea 2.5.5) (7u79-2.5.5-0ubuntu0.12.04.1)OpenJDK 64-Bit Server VM (build 24.79-b02, mixed mode)Ubuntu的apt-get安装方式和CentOS的yum安装方式很类似，这里就不再啰嗦。","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"centos7","slug":"centos7","permalink":"http://blog.liurenjie.top/tags/centos7/"},{"name":"centos6","slug":"centos6","permalink":"http://blog.liurenjie.top/tags/centos6/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.liurenjie.top/tags/ubuntu/"},{"name":"jdk","slug":"jdk","permalink":"http://blog.liurenjie.top/tags/jdk/"}]},{"title":"连接mysql数据库遇到的问题","slug":"mysql2017-01-11-2","date":"2017-01-11T13:34:44.000Z","updated":"2018-06-01T01:42:51.424Z","comments":true,"path":"posts/223b6078.html","link":"","permalink":"http://blog.liurenjie.top/posts/223b6078.html","excerpt":"Table &#39;performance_schema.session_variables&#39; doesn&#39;t exist解决方法：12mysql -u app -pmysql&gt; set @@global.show_compatibility_56=ON;最终在stackoverflw中找到答案,主要产生原因,以前的data是mysql5.6中的.新装的mysql是5.7的.之间版本不一致导致.解决方案2部执行:?mysql_upgrade -u root -p --force重启mysql","text":"Table &#39;performance_schema.session_variables&#39; doesn&#39;t exist解决方法：12mysql -u app -pmysql&gt; set @@global.show_compatibility_56=ON;最终在stackoverflw中找到答案,主要产生原因,以前的data是mysql5.6中的.新装的mysql是5.7的.之间版本不一致导致.解决方案2部执行:?mysql_upgrade -u root -p --force重启mysql另一个错误[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated c在 /etc/my.cnf 文件里加上如下：sql_mode=&#39;NO_ENGINE_SUBSTITUTION&#39;然后，重启Mysql服务就可以解决了！","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://blog.liurenjie.top/tags/centos7/"},{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"}]},{"title":"在centos7上搭建mysql环境","slug":"linux2017-01-11-1","date":"2017-01-11T09:51:24.000Z","updated":"2018-06-01T01:42:51.403Z","comments":true,"path":"posts/4170035f.html","link":"","permalink":"http://blog.liurenjie.top/posts/4170035f.html","excerpt":"安装环境：CentOS7 64位 MINI版，安装MySQL5.7配置YUM源在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/1234# 下载mysql源安装包shell&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 安装mysql源shell&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm","text":"安装环境：CentOS7 64位 MINI版，安装MySQL5.7配置YUM源在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/1234# 下载mysql源安装包shell&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 安装mysql源shell&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm检查mysql源是否安装成功1shell&gt; yum repolist enabled | grep \"mysql.*-community.*\"看到上图所示表示安装成功。 可以修改vim /etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。比如要安装5.6版本，将5.7源的enabled=1改成enabled=0。然后再将5.6源的enabled=0改成enabled=1即可。改完之后的效果如下所示：安装MySQL1shell&gt; yum install mysql-community-server启动MySQL服务1shell&gt; systemctl start mysqld查看MySQL的启动状态12345678910shell&gt; systemctl status mysqld● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; disabled; vendor preset: disabled) Active: active (running) since 五 2016-06-24 04:37:37 CST; 35min ago Main PID: 2888 (mysqld) CGroup: /system.slice/mysqld.service └─2888 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid6月 24 04:37:36 localhost.localdomain systemd[1]: Starting MySQL Server...6月 24 04:37:37 localhost.localdomain systemd[1]: Started MySQL Server.开机启动12shell&gt; systemctl enable mysqldshell&gt; systemctl daemon-reload修改root本地登录密码mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：1shell&gt; grep 'temporary password' /var/log/mysqld.log12shell&gt; mysql -uroot -pmysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!';或者1mysql&gt; set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;MyNewPass4!&apos;);注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误，如下图所示：通过msyql环境变量可以查看密码策略的相关信息：1mysql&gt; show variables like &apos;%password%&apos;;validate_password_policy：密码策略，默认为MEDIUM策略validate_password_dictionary_file：密码策略文件，策略为STRONG才需要validate_password_length：密码最少长度validate_password_mixed_case_count：大小写字符长度，至少1个validate_password_number_count ：数字至少1个validate_password_special_char_count：特殊字符至少1个上述参数是默认策略MEDIUM的密码检查规则。共有以下几种密码策略：| 策略 | 检查规则 || ———– | ———————————————————— || 0 or LOW | Length || 1 or MEDIUM | Length; numeric, lowercase/uppercase, and special characters || 2 or STRONG | Length; numeric, lowercase/uppercase, and special characters; dictionary file |MySQL官网密码策略详细说明：http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy修改密码策略在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略12# 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件validate_password_policy=012如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：1validate_password = off1重新启动mysql服务使配置生效：1systemctl restart mysqld添加远程登录用户默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，我添加一个新的帐户：1mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;yangxin&apos;@&apos;%&apos; IDENTIFIED BY &apos;Yangxin0917!&apos; WITH GRANT OPTION;配置默认编码为utf8修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：123[mysqld]character_set_server=utf8init_connect=&apos;SET NAMES utf8&apos;123重新启动mysql服务，查看数据库默认编码如下所示：默认配置文件路径：配置文件：/etc/my.cnf日志文件：/var/log//var/log/mysqld.log服务启动脚本：/usr/lib/systemd/system/mysqld.servicesocket文件：/var/run/mysqld/mysqld.pid","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/categories/linux/"}],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://blog.liurenjie.top/tags/centos7/"},{"name":"mysql","slug":"mysql","permalink":"http://blog.liurenjie.top/tags/mysql/"}]},{"title":"服务器上搭建ss","slug":"shadowsocks2017-01-11-1","date":"2017-01-11T00:00:00.000Z","updated":"2018-06-01T01:42:51.453Z","comments":true,"path":"posts/aeb522b6.html","link":"","permalink":"http://blog.liurenjie.top/posts/aeb522b6.html","excerpt":"本脚本适用环境：系统支持：CentOS 6，7，Debian，Ubuntu内存要求：≥128M日期：2016 年 08 月 18 日关于本脚本：一键安装 Python 版 Shadowsocks 的最新版，同时安装了 Python 包管理工具 pip。友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。","text":"本脚本适用环境：系统支持：CentOS 6，7，Debian，Ubuntu内存要求：≥128M日期：2016 年 08 月 18 日关于本脚本：一键安装 Python 版 Shadowsocks 的最新版，同时安装了 Python 包管理工具 pip。友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。默认配置：服务器端口：自己设定（如不设定，默认为8989）客户端端口：1080密码：自己设定（如不设定，默认为teddysun.com）备注：脚本默认创建单用户配置文件，如需配置多用户，安装完毕后参照下面的教程 sample 手动修改配置文件后重启即可。客户端下载：https://github.com/shadowsocks/shadowsocks-windows/releases使用方法：使用root用户登录，运行以下命令：123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log安装完成后，脚本提示如下：12345678910Congratulations, shadowsocks install completed! Your Server IP:your_server_ip Your Server Port:your_server_port Your Password:your_password Your Local IP:127.0.0.1 Your Local Port:1080 Your Encryption Method:aes-256-cfb Welcome to visit:https://teddysun.com/342.html Enjoy it!卸载方法：使用root用户登录，运行以下命令：./shadowsocks.sh uninstall单用户配置文件 Sample（2015 年 08 月 28 日修正）：配置文件路径：/etc/shadowsocks.json12345678910&#123; \"server\":\"0.0.0.0\", \"server_port\":8989, \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"password\":\"yourpassword\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false &#125;多用户多端口配置文件 Sample（2015 年 08 月 28 日修正）：配置文件路径：/etc/shadowsocks.json多用户多端口配置文件 Sample（2015 年 08 月 28 日修正）：配置文件路径：/etc/shadowsocks.json123456789101112131415&#123; \"server\":\"0.0.0.0\", \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":&#123; \"8989\":\"password0\", \"9001\":\"password1\", \"9002\":\"password2\", \"9003\":\"password3\", \"9004\":\"password4\" &#125;, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false&#125;使用命令（2015 年 08 月 28 日修正）：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status显示配置：vi /etc/shadowsocks.json","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.liurenjie.top/categories/shadowsocks/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.liurenjie.top/tags/shadowsocks/"},{"name":"linux","slug":"linux","permalink":"http://blog.liurenjie.top/tags/linux/"}]},{"title":"防止ajax表单重复提交","slug":"javascript2017-01-09-1","date":"2017-01-09T00:00:00.000Z","updated":"2018-05-25T07:56:29.427Z","comments":true,"path":"posts/7695639d.html","link":"","permalink":"http://blog.liurenjie.top/posts/7695639d.html","excerpt":"123456789beforeSend :function()&#123; btn.setAttribute(\"disabled\", true); &#125;, success:function(data)&#123; // console.log(data); &#125;, complete :function()&#123; setTimeout(function()&#123;btn.removeAttribute(\"disabled\");&#125;,2000); &#125;","text":"123456789beforeSend :function()&#123; btn.setAttribute(\"disabled\", true); &#125;, success:function(data)&#123; // console.log(data); &#125;, complete :function()&#123; setTimeout(function()&#123;btn.removeAttribute(\"disabled\");&#125;,2000); &#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"}]},{"title":"JVM原理（Java代码编译和执行的整个过程+JVM内存管理及垃圾回收机制）","slug":"java2016-12-30-1","date":"2016-12-30T09:32:21.000Z","updated":"2018-05-31T03:34:07.505Z","comments":true,"path":"posts/6620919c.html","link":"","permalink":"http://blog.liurenjie.top/posts/6620919c.html","excerpt":"JVM工作原理和特点主要是指操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.创建JVM装载环境和配置装载JVM.dll初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例调用JNIEnv实例装载并处理class类。","text":"JVM工作原理和特点主要是指操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.创建JVM装载环境和配置装载JVM.dll初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例调用JNIEnv实例装载并处理class类。在我们运行和调试Java程序的时候,经常会提到一个JVM的概念.JVM是Java程序运行的环境,但是他同时一个操作系统的一个应用程序一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间.首先来说一下JVM工作原理中的jdk这个东西,不管你是初学者还是高手,是j2ee程序员还是j2se程序员,jdk总是在帮我们做一些事情.我们在了解Java之前首先大师们会给我们提供说jdk这个东西.它在Java整个体系中充当着什么角色呢?我很惊叹sun大师们设计天才,能把一个如此完整的体系结构化的如此完美.jdk在这个体系中充当一个生产加工中心,产生所有的数据输出,是所有指令和战略的执行中心.本身它提供了Java的完整方案,可以开发目前Java能支持的所有应用和系统程序.这里说一个问题,大家会问,那为什么还有j2me,j2ee这些东西,这两个东西目的很简单,分别用来简化各自领域内的开发和构建过程.jdk除了JVM之外,还有一些核心的API,集成API,用户工具,开发技术,开发工具和API等组成好了,废话说了那么多,来点于主题相关的东西吧.JVM在整个jdk中处于最底层,负责于操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也就虚拟计算机. 操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.创建JVM装载环境和配置装载JVM.dll初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例调用JNIEnv实例装载并处理class类。一．JVM装入环境，JVM提供的方式是操作系统的动态连接文件．既然是文件那就一个装入路径的问题，Java是怎么找这个路径的呢？当你在调用Java test的时候，操作系统会在path下在你的Java.exe程序，Java.exe就通过下面一个过程来确定JVM的路径和相关的参数配置了．下面基于Windows的实现的分析．首先查找jre路径，Java是通过GetApplicationHome api来获得当前的Java.exe绝对路径，c:\\j2sdk1.4.2_09\\bin\\Java.exe,那么它会截取到绝对路径c:\\j2sdk1.4.2_09\\，判断c:\\j2sdk1.4.2_09\\bin\\Java.dll文件是否存在，如果存在就把c:\\j2sdk1.4.2_09\\作为jre路径，如果不存在则判断c:\\j2sdk1.4.2_09\\jre\\bin\\Java.dll是否存在，如果存在这c:\\j2sdk1.4.2_09\\jre作为jre路径．如果不存在调用GetPublicJREHome查HKEY_LOCAL_MACHINE\\Software\\JavaSoft\\Java Runtime Environment\\“当前JRE版本号”\\JavaHome的路径为jre路径。然后装载JVM.cfg文件JRE路径+\\lib+\\ARCH（CPU构架）+\\JVM.cfgARCH（CPU构架）的判断是通过Java_md.c中GetArch函数判断的，该函数中windows平台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。以我的为例：C:\\j2sdk1.4.2_09\\jre\\lib\\i386\\JVM.cfg.主要的内容如下：-client KNOWN-server KNOWN-hotspot ALIASED_TO -client-classic WARN-native ERROR-green ERROR在我们的jdk目录中jre\\bin\\server和jre\\bin\\client都有JVM.dll文件存在，而Java正是通过JVM.cfg配置文件来管理这些不同版本的JVM.dll的．通过文件我们可以定义目前jdk中支持那些JVM,前面部分（client）是JVM名称，后面是参数，KNOWN表示JVM存在，ALIASED_TO表示给别的JVM取一个别名，WARN表示不存在时找一个JVM替代，ERROR表示不存在抛出异常．在运行Java XXX是，Java.exe会通过CheckJVMType来检查当前的JVM类型，Java可以通过两种参数的方式来指定具体的JVM类型，一种按照JVM.cfg文件中的JVM名称指定，第二种方法是直接指定，它们执行的方法分别是“Java -J”、“Java -XXaltJVM=”或“Java -J-XXaltJVM=”。如果是第一种参数传递方式，CheckJVMType函数会取参数‘-J’后面的JVM名称，然后从已知的JVM配置参数中查找如果找到同名的则去掉该JVM名称前的‘-’直接返回该值；而第二种方法，会直接返回“-XXaltJVM=”或“-J-XXaltJVM=”后面的JVM类型名称；如果在运行Java时未指定上面两种方法中的任一一种参数，CheckJVMType会取配置文件中第一个配置中的JVM名称，去掉名称前面的‘-’返回该值。CheckJVMType函数的这个返回值会在下面的函数中汇同jre路径组合成JVM.dll的绝对路径。如果没有指定这会使用JVM.cfg中第一个定义的JVM.可以通过set _Java_LAUNCHER_DEBUG=1在控制台上测试．最后获得JVM.dll的路径，JRE路径+\\bin+\\JVM类型字符串+\\JVM.dll就是JVM的文件路径了，但是如果在调用Java程序时用-XXaltJVM=参数指定的路径path,就直接用path+\\JVM.dll文件做为JVM.dll的文件路径．二：装载JVM.dll通过第一步已经找到了JVM的路径，Java通过LoadJavaVM来装入JVM.dll文件．装入工作很简单就是调用Windows API函数：LoadLibrary装载JVM.dll动态连接库．然后把JVM.dll中的导出函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs挂接到InvocationFunctions变量的CreateJavaVM和GetDefaultJavaVMInitArgs函数指针变量上。JVM.dll的装载工作宣告完成。三：初始化JVM，获得本地调用接口，这样就可以在Java中调用JVM的函数了．调用InvocationFunctions－&gt;CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例．四：运行Java程序．Java程序有两种方式一种是jar包，一种是class. 运行jar,Java -jar XXX.jar运行的时候，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用Java类Java.util.jar.JarFileJNIEnv中方法getManifest()并从返回的Manifest对象中取getAttributes(&quot;Main-Class&quot;)的值即jar包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。main函数直接调用Java.c中LoadClass方法装载该类。如果是执行class方法。main函数直接调用Java.c中LoadClass方法装载该类。然后main函数调用JNIEnv实例的GetStaticMethodID方法查找装载的class主类中“public static void main(String[] args)”方法，并判断该方法是否为public方法，然后调用JNIEnv实例的CallStaticVoidMethod方法调用该Java类的main方法。从Java平台的逻辑结构上来看，我们可以从下图来了解JVM：从上图能清晰看到Java平台包含的各个逻辑模块，也能了解到JDK与JRE的区别对于JVM自身的物理结构，我们可以从下图鸟瞰一下：对于JVM的学习，在我看来这么几个部分最重要：Java代码编译和执行的整个过程JVM内存管理及垃圾回收机制下面将这两个部分进行详细学习Java代码编译是由Java源码编译器来完成，流程图如下所示Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制类加载机制类执行机制Java源码编译机制Java 源码编译由以下三个过程组成：分析和输入到符号表注解处理语义分析和生成class文件流程图如下所示：最后生成的class文件由以下部分组成：结构信息。包括class文件格式版本号及各部分的数量与大小的信息元数据。对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池方法信息。对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息类加载机制JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：Bootstrap ClassLoader负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类Extension ClassLoader负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包App ClassLoader负责记载classpath中指定的jar包及目录中classCustom ClassLoader属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。类执行机制JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：JVM内存组成结构JVM栈由堆、栈、本地方法栈、方法区等部分组成，结构图如下所示：堆所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由From Space和To Space组成，结构图如下所示：新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象栈每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果本地方法栈用于支持native方法的执行，存储了每个native方法调用的状态方法区存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代（Permanet Generation）来存放方法区，可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值垃圾回收机制JVM分别对新生代和旧生代采用不同的垃圾回收机制新生代的GC：新生代通常存活时间较短，因此基于Copying算法来进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和From Space或To Space之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从eden到survivor，最后到旧生代，用java visualVM来查看，能明显观察到新生代满了后，会把对象转移到旧生代，然后清空继续装载，当旧生代也满了后，就会报outofmemory的异常，如下图所示：在执行机制上JVM提供了串行GC（Serial GC）、并行回收GC（Parallel Scavenge）和并行GC（ParNew）串行GC在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定并行回收GC在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数并行GC与旧生代的并发GC配合使用旧生代的GC：旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上JVM提供了串行GC（Serial MSC）、并行GC（parallel MSC）和并发GC（CMS），具体算法细节还有待进一步深入研究。以上各种GC机制是需要组合使用的，指定方式由下表所示：指定方式新生代GC方式旧生代GC方式-XX:+UseSerialGC串行GC串行GC-XX:+UseParallelGC并行回收GC并行GC-XX:+UseConeMarkSweepGC并行GC并发GC-XX:+UseParNewGC并行GC串行GC-XX:+UseParallelOldGC并行回收GC并行GC-XX:+ UseConeMarkSweepGC-XX:+UseParNewGC串行GC并发GC不支持的组合1、-XX:+UseParNewGC -XX:+UseParallelOldGC2、-XX:+UseParNewGC -XX:+UseSerialGC内存调优首先需要注意的是在对JVM内存调优的时候不能只看操作系统级别Java进程所占用的内存，这个数值不能准确的反应堆内存的真实占用情况，因为GC过后这个值是不会变化的，因此内存调优的时候要更多地使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理，导致Full GC一般由于以下几种情况：旧生代空间不足调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象Pemanet Generation空间不足增大Perm Gen空间，避免太多静态对象统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间控制好新生代和旧生代的比例System.gc()被显示调用垃圾回收不要手动触发，尽量依靠JVM自身的机制调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果新生代设置过小一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC新生代设置过大一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加一般说来新生代占整个堆1/3比较合适Survivor设置过小导致对象从eden直接到达旧生代，降低了在新生代的存活时间Survivor设置过大导致eden过小，增加了GC频率另外，通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收由上述可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式吞吐量优先JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置暂停时间优先JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置最后汇总一下JVM常见配置堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。附：本系列学习资料主要来自博文http://rednaxelafx.javaeye.com/blog/656951里提到的PPT和《分布式Java应用》里有关JVM的章节，推荐大家继续深入学习","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://blog.liurenjie.top/tags/jvm/"}]},{"title":"js输入文本验证","slug":"javascript2016-12-29-1","date":"2016-12-29T00:00:00.000Z","updated":"2018-05-25T07:56:29.430Z","comments":true,"path":"posts/e69fdf4.html","link":"","permalink":"http://blog.liurenjie.top/posts/e69fdf4.html","excerpt":"JS判断只能是数字和小数点不能输入中文1234567891011121314151617&lt;input onpaste=\"return false;\" type=\"text\" name=\"textfield\" style=\"width:400px; ime-mode:disabled\" value=\"\"&gt;&lt;script&gt;function chkIt(frm)&#123; if (frm.n1.value.length&gt;0&amp;&amp;frm.n1.value.match(/[\\x01-\\xFF]*/)==false)&#123; alert('n1不能输入中文！') frm.n1.focus(); return false; &#125;&#125;&lt;/script&gt;&lt;body&gt;&lt;form onsubmit=\"return chkIt(this)\"&gt;&lt;input name=\"n1\"&gt;&lt;input name=\"n2\"&gt;&lt;input name=\"smt\" type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;","text":"JS判断只能是数字和小数点不能输入中文1234567891011121314151617&lt;input onpaste=\"return false;\" type=\"text\" name=\"textfield\" style=\"width:400px; ime-mode:disabled\" value=\"\"&gt;&lt;script&gt;function chkIt(frm)&#123; if (frm.n1.value.length&gt;0&amp;&amp;frm.n1.value.match(/[\\x01-\\xFF]*/)==false)&#123; alert('n1不能输入中文！') frm.n1.focus(); return false; &#125;&#125;&lt;/script&gt;&lt;body&gt;&lt;form onsubmit=\"return chkIt(this)\"&gt;&lt;input name=\"n1\"&gt;&lt;input name=\"n2\"&gt;&lt;input name=\"smt\" type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;文本框只能输入数字代码(小数点也不能输入)1&lt;input onkeyup=\"this.value=this.value.replace(/\\D/g,'')\" onafterpaste=\"this.value=this.value.replace(/\\D/g,'')\"&gt;只能输入数字,能输小数点.12&lt;input onkeyup=\"if(isNaN(value))execCommand('undo')\" onafterpaste=\"if(isNaN(value))execCommand('undo')\"&gt; &lt;input name=txt1 onchange=\"if(/\\D/.test(this.value))&#123;alert('只能输入数字');this.value='';&#125;\"&gt;数字和小数点方法二1234&lt;input type=text t_value=\"\" o_value=\"\" onkeypress=\"if(!this.value.match(/^[\\+\\-]?\\d*?\\.?\\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?)?$/))this.o_value=this.value\" onkeyup=\"if(!this.value.match(/^[\\+\\-]?\\d*?\\.?\\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?)?$/))this.o_value=this.value\" onblur=\"if(!this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?|\\.\\d*?)?$/))this.value=this.o_value;else&#123;if(this.value.match(/^\\.\\d+$/))this.value=0+this.value;if(this.value.match(/^\\.$/))this.value=0;this.o_value=this.value&#125;\"&gt;只能输入字母和汉字1&lt;input onkeyup=\"value=value.replace(/[\\d]/g,'') \"onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[\\d]/g,''))\" maxlength=10 name=\"Numbers\"&gt;只能输入英文字母和数字,不能输入中文1&lt;input onkeyup=\"value=value.replace(/[^\\w\\.\\/]/ig,'')\"&gt;只能输入数字和英文1&lt;input onKeyUp=\"value=value.replace(/[^\\d|chun]/g,'')\"&gt;小数点后只能有最多两位(数字,中文都可输入),不能输入字母和运算符号:1&lt;input onKeyPress=\"if((event.keyCode&lt;48 || event.keyCode&gt;57) &amp;&amp; event.keyCode!=46 || /\\.\\d\\d$/.test(value))event.returnValue=false\"&gt;小数点后只能有最多两位(数字,字母,中文都可输入),可以输入运算符号:1&lt;input onkeyup=\"this.value=this.value.replace(/^(\\-)*(\\d+)\\.(\\d\\d).*$/,'$1$2.$3')\"&gt;禁止特殊字符：1onKeyPress=\"if(event.keyCode &lt; 45 || event.keyCode &gt; 57 ) event.returnValue = false;\"只能输入汉字：1&lt;input onkeyup=\"value=value.replace(/[^/u4E00-/u9FA5]/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^/u4E00-/u9FA5]/g,''))\"&gt;禁止汉字输入法1style=\"ime-mode:disabled\"只能输入数字：1&lt;input onkeyup=\"value=value.replace(/[^/d]/g,'') \"onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^/d]/g,''))\"&gt;只能输入英文和数字：1&lt;input onkeyup=\"value=value.replace(/[/W]/g,'') \"onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^/d]/g,''))\"&gt;控制输入框只能输入文字或数字，也可以不允许输入特殊字符 这里不允许输入如下字符: (像 ^&amp;* 等)1&lt;textarea rows=2 cols=20 name=comments onKeypress=\"if ((event.keyCode &gt; 32 &amp;&amp; event.keyCode &lt; 48) || (event.keyCode &gt; 57 &amp;&amp; event.keyCode &lt; 65) || (event.keyCode &gt; 90 &amp;&amp; event.keyCode &lt; 97)) event.returnValue = false;\"&gt;只禁止空格输入123onkeyup=\"value=value.replace(//s/g,'')\"onkeydown=\"if(event.keyCode==32) return false\"只能输入中文和英文：1onkeyup=\"value=value.replace(//a-zA-Z/u4E00-/u9FA5/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(//a-zA-Z/u4E00-/u9FA5/g,''))\"不允许输入特殊字符和空格:1&lt;input id=\"code\" onkeypress=\"return ValidateSpecialCharacter();\" onblur=\"validate(this)\"/&gt;————————————————————————————————————————不能为空1&lt;input onblur=\"if(this.value.replace(/^ +| +$/g,'')=='')alert('不能为空!')\"&gt;判断字符由字母和数字，下划线,点号组成.且开头的只能是下划线和字母1/^([a-zA-z_]&#123;1&#125;)([\\w]*)$/g.test(str)只能输入数字1&lt;input name=\"text\" type=\"text\" id=\"NewPage\" onKeyUp=\"value=value.replace(/\\D/g,'')\" onafterpaste=\"value=value.replace(/\\D/g,'')\" &gt;只能输入中文1&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\u4E00-\\u9FA5]/g,'')\"&gt;只能输入英文123&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\a-\\z\\A-\\Z]/g,'')\"&gt;&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^a-zA-Z]/g,'')\"&gt;只能输入中文、英文、数字、@符号和.符号1&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\a-\\z\\A-\\Z0-9\\u4E00-\\u9FA5\\@\\.]/g,'')\"&gt;只允许输入英文，且不能粘贴也无法弹出粘贴菜单1&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\a-\\z\\A-\\Z]/g,'')\" onkeydown=\"fncKeyStop(event)\" onpaste=\"return false\" oncontextmenu = \"return false\"/&gt;只能输入数字和点号(注意:在[^\\d.]里的d不能写成大写D,否则就变成除了数字以外的所有字符)1&lt;input name=\"price\" type=\"text\" size=\"8\" maxlength=\"8\" onkeyup=\"value=value.replace(/[^\\d\\.]/g,'')\" &gt;总而言之:先在&lt;input&gt;里输入onkeyup=&quot;value=value.replace(/[^\\X]/g,&#39;&#39;)&quot; 然后在(/[\\X]/g,’’)里的X换成你想输入的代码就可以了中文：u4E00-u9FA5数字：d、0-9英文：a-z、A-Z其它符号@,点或其它符号.也可以多个,用\\隔开就行了.例如:中、英文和数字加@符号加点符号：\\a-\\z\\A-\\Z0-9\\u4E00-\\u9FA5\\@.若 想在文本框里不能右键弹出菜单和不能粘贴进复制的信息的话就要在&lt;input&gt;里输入onKeyDown=&quot;fncKeyStop(event)&quot; onpaste=&quot;return false&quot; oncontextmenu=&quot;return false;&quot;-————————————————————————————————————————————–只允许输入数字和小数点。1&lt;input onKeypress=\"return (/[/d.]/.test(String.fromCharCode(event.keyCode)))\" style=\"ime-mode:Disabled\"&gt;判断的更详细一些，甚至22..2这样不算数字也判断得出来123456789101112131415&lt;script&gt; function check()&#123; if (isNaN(tt.value)) &#123;alert(\"非法字符！\"); tt.value=\"\";&#125; &#125; &lt;/script&gt; &lt;input type=\"text\" name=\"tt\" onkeyup=\"check();\"&gt;只允许输入整数。其实也完全可以根据第三条来举一反三做一些限制。1234567891011121314151617&lt;script language=javascript&gt; function onlyNum() &#123; if(!(event.keyCode==46)&amp;&amp;!(event.keyCode==8)&amp;&amp;!(event.keyCode==37)&amp;&amp;!(event.keyCode==39)) if(!((event.keyCode&gt;=48&amp;&amp;event.keyCode&lt;=57)||(event.keyCode&gt;=96&amp;&amp;event.keyCode&lt;=105))) event.returnValue=false; &#125; &lt;/script&gt;&lt;input onkeydown=\"onlyNum();\" style=\"ime-mode:Disabled&gt;结语,其实style=”ime-mode:Disabled这句是比较实用的。意为关闭输入法。省得有些人开着全角输入数字，结果输入不进去来找你哭天抹泪的，还怪你设计的不好。只允许输入数字1&lt;input name=\"username\" type=\"text\" onkeyup=\"value=this.value.replace(//D+/g,'')\"&gt;只允许输入英文字母、数字和下划线(以下二种方法实现)123&lt;input name=\"username\" type=\"text\" style=\"ime-mode:disabled\"&gt; &lt;input name=\"username\" type=\"text\" onkeyup=\"value=value.replace(/[^/w/.//]/ig,'')\"&gt;只允许输入英文字母、数字和&amp;=@1&lt;input name=\"username\" type=\"text\" onkeyup=\"value=value.replace(/[^/w=@&amp;]|_/ig,'')\"&gt;只允许输入汉字123&lt;input name=\"username\" type=\"text\" onkeyup=\"value=value.replace(/[^/u4E00-/u9FA5]/g,'')\"&gt;&lt;input name=\"username\" type=\"text\" onkeyup=\"value=value.replace(/[^/w/.//]/ig,'')\"&gt; &lt;input name=\"username\" type=\"text\" style=\"ime-mode:disabled\"&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://blog.liurenjie.top/tags/html/"}]},{"title":"根据字节数获取字符长度 并截取","slug":"javascript2016-12-20-1","date":"2016-12-20T00:00:00.000Z","updated":"2018-05-25T07:56:29.423Z","comments":true,"path":"posts/f3825253.html","link":"","permalink":"http://blog.liurenjie.top/posts/f3825253.html","excerpt":"1234567891011String.prototype.gblen = function() &#123; ///&lt;summary&gt;获得字符串实际长度，中文2，英文1&lt;/summary&gt; ///&lt;param name=\"str\"&gt;要获得长度的字符串&lt;/param&gt; var realLength = 0, len = this.length, charCode = -1; for (var i = 0; i &lt; len; i++) &#123; charCode = this.charCodeAt(i); if (charCode &gt;= 0 &amp;&amp; charCode &lt;= 128) realLength += 1; else realLength += 2; &#125; return realLength; &#125;","text":"1234567891011String.prototype.gblen = function() &#123; ///&lt;summary&gt;获得字符串实际长度，中文2，英文1&lt;/summary&gt; ///&lt;param name=\"str\"&gt;要获得长度的字符串&lt;/param&gt; var realLength = 0, len = this.length, charCode = -1; for (var i = 0; i &lt; len; i++) &#123; charCode = this.charCodeAt(i); if (charCode &gt;= 0 &amp;&amp; charCode &lt;= 128) realLength += 1; else realLength += 2; &#125; return realLength; &#125;123456789101112131415161718192021222324252627282930313233 //js截取字符串，中英文都能用 //如果给定的字符串大于指定长度，截取指定长度返回，否者返回源字符串。 //字符串，长度 /** * js截取字符串，中英文都能用 * @param str：需要截取的字符串 * @param len: 需要截取的长度 */ String.prototype.subStrByByte = function(len) &#123; var str_length = 0; var str_len = 0; str_cut = new String(); str_len = this.length; for (var i = 0; i &lt; str_len; i++) &#123; a = this.charAt(i); str_length++; if (escape(a).length &gt; 4) &#123; //中文字符的长度经编码之后大于4 str_length++; &#125; str_cut = str_cut.concat(a); if (str_length &gt;= len) &#123;// str_cut = str_cut.concat(\"...\"); return str_cut; &#125; &#125; //如果给定字符串小于指定长度，则返回源字符串； if (str_length &lt; len) &#123; return this; &#125; &#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.liurenjie.top/tags/javascript/"}]},{"title":"eclipse+gradle构建项目","slug":"java2016-12-12-1","date":"2016-12-12T21:53:55.000Z","updated":"2018-05-31T03:12:47.627Z","comments":true,"path":"posts/2b851410.html","link":"","permalink":"http://blog.liurenjie.top/posts/2b851410.html","excerpt":"我第一次用gradle构建项目，首先下载gradle插件。eclipse—help—eclipseMarketplace搜素gradle，查看结果Gradle IDE Pack 3.6.x+0.17下载就好了。创建一个新的项目","text":"我第一次用gradle构建项目，首先下载gradle插件。eclipse—help—eclipseMarketplace搜素gradle，查看结果Gradle IDE Pack 3.6.x+0.17下载就好了。创建一个新的项目配置build.gradle文件。1234567891011121314151617181920212223242526272829303132333435363738394041apply plugin: 'java' apply plugin: 'eclipse' apply plugin: 'spring-boot' sourceCompatibility = 1.8 //定义java jdk版本 version = '1.0' jar &#123; manifest &#123; attributes 'Implementation-Title': 'spring-boot Gradle Quickstart', 'Implementation-Version': version &#125; &#125; repositories &#123; //指定maven仓库路径 mavenLocal() maven &#123; url \"https://repo.spring.io/libs-release\" &#125; &#125; dependencies &#123;//需要的jar依赖 compile ( 'org.springframework.boot:spring-boot-starter-web', //springboot主要依赖 'commons-collections:commons-collections:3.2', 'junit:junit:4.+' ) &#125; test &#123; systemProperties 'property': 'value' &#125; buildscript &#123; repositories &#123; mavenLocal() maven &#123; url \"https://repo.spring.io/libs-release\" &#125; &#125; dependencies &#123; classpath( 'org.springframework.boot:spring-boot-gradle-plugin:1.3.6.RELEASE' ) &#125; &#125;创建一个ApplicationStartUp.java123456789101112131415package org.gradle.boot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @EnableAutoConfiguration @ComponentScan(basePackages = &#123;\"org.gradle\"&#125;) public class ApplicationStartUp &#123; public static void main(String[] args) &#123; SpringApplication.run(ApplicationStartUp.class); &#125; &#125;ThisWillController1234567891011121314package org.gradle.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class ThisWillController &#123; @RequestMapping(value = \"/\" , method = RequestMethod.GET) public String index()&#123; return \"hello word !\"; &#125; &#125;可以创建一个properties文件，配置端口及其他配置。（这里我只是简单的配置了端口，和日志文件）1234#\\u7AEF\\u53E3\\u53F7 server.port=8081 #\\u65E5\\u5FD7\\u5B58\\u653E\\u4F4D\\u7F6E logging.file=myLog.log","categories":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.liurenjie.top/tags/java/"},{"name":"gradle","slug":"gradle","permalink":"http://blog.liurenjie.top/tags/gradle/"},{"name":"eclipse","slug":"eclipse","permalink":"http://blog.liurenjie.top/tags/eclipse/"}]},{"title":"Hello World","slug":"hello-world","date":"2015-05-17T00:00:00.000Z","updated":"2018-06-01T01:42:51.382Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"http://blog.liurenjie.top/posts/4a17b156.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: DeploymentWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: DeploymentWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[{"name":"world","slug":"world","permalink":"http://blog.liurenjie.top/categories/world/"}],"tags":[{"name":"world","slug":"world","permalink":"http://blog.liurenjie.top/tags/world/"}]},{"title":"Test","slug":"test","date":"2015-05-16T00:00:00.000Z","updated":"2018-05-30T07:45:03.544Z","comments":true,"path":"posts/784dd132.html","link":"","permalink":"http://blog.liurenjie.top/posts/784dd132.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://blog.liurenjie.top/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://blog.liurenjie.top/tags/test/"}]}]}